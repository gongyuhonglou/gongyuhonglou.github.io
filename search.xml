<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JIRA - 使用指南(项目跟踪管理工具)]]></title>
    <url>%2FJIRA%20-%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97(%E9%A1%B9%E7%9B%AE%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7).html</url>
    <content type="text"><![CDATA[第一章、前言 JIRA 是澳大利亚 Atlassian 公司开发的一款优秀的问题跟踪管理软件工具，可以对各种类型的问题进行跟踪管理，包括缺陷、任务、需求、改进等。JIRA采用J2EE技术，能够跨平台部署。它正被广泛的开源软件组织，以及全球著名的公司使用。 JIRA产品非常完善且功能强大，安装配置简单，多语言支持、界面十分友好，和 其他系统如CVS、Subversion（SVN）、VSS、LDAP、邮件服务整合得相当好，文档齐全，可用性以及可扩展性方面都十分出色，拥有完整的用户权限管理。 您可在JIRA中国网站 http://www.fangwai.net/ 上了解到JIRA 更为详细的信息。 此文档主要介绍了JIRA产品的特性、安装配置、基本概念及操作。为您评估使用JIRA提供一个基本的指南。另外，本文档中介绍的部分功能是JIRA企业版独有的，如：项目类别管理功能、设置模块负责人。 第二章、JIRA介绍跟踪并管理在项目开发和维护过程中出现的问题（如：缺陷、新特性、任务、 改进等）是 项目管理很重要的任务，但是很少有团队能做的很好。 JIRA作为一个专业的问题跟踪系统可以帮助您把 缺陷管理起来，让跟踪和管理在项目中发现的问题变得简单，而且充分利用JIRA的灵活配置和扩展特性，可以将JIRA作为一个项目管理系统或者IT支持系统。 2.1 JIRA 的特性1) 管理缺陷，新特性、任务、改进或者其他任何问题2) 干净和强大的用户界面 3) 灵活的 工作流定制 4) 全文搜索和强大的过滤器 5) 企业级的权限和安全控制 6) 非常灵活的邮件通知配置 7) 可以创建子任务 8) 方便的扩展及与其他系统集成：包括 email 、LDAP 和源码控制工具等； 9) 丰富插件库 10) 项目类别和组件/模块管理 11) 可以在几乎所有硬件、 操作系 统和 数据 库平台上运行 2.2 JIRA 的版本为了适应不同用户的使用需求，JIRA产品提供三种版本，分别为：标准版，专业版和企业版，这三种版本在功能上有区别。企业版的功能最全，含盖了标准版和专业版的全部功能并有较多增强的功能，专业版则包含了标准版的全部功能并有一些增强功能，标准版本是JIRA的基础版本。 2.2.1 企业版是为企业级用户设计的，它与标准版，专业版相比，具有以下一些独有的、重要的功能： 1)项目类别管理功能：可以将相关的项目分组管理。2)组件/模块负责人功能：可以将项目的不同组件/模块指派相应的负责人，来处理所负责的组件的Issues。 3)项目email地址功能：每个项目可以有不同的email（该项目的通知邮件从该地址发出）。 4)LDAP配置器：用于将JIRA连接到公司的LDAP目录上。 5)Issue安全级别：在一个项目里可以精确地控制对Issue的访问。 6)无限制的工作流：可以创建多个工作流为不同的项目使用； 2.2.2 专业版是为部门级设计的。它不具备JIRA企业版独有的功能，但是它与JIRA标准版相比多出了如下几个方面的功能： 1)子任务功能：可以在某个Issue下创建子任务；2)共享过滤器功能：一个团队成员可以访问共享的过滤器； 3)Multiple dashboards功能：可以定制自己的JIRA显示面板； 4)工作流编辑功能：可以对workflow进行编辑； 5)无限制的CVS repositories。 2.2.3 标准版是为工作组级别设计的。它不具备上述的JIRA专业版和企业版的增强功能，具有JIRA的标准功能. 2.3 JIRA中涉及的角色JIRA作为一个缺陷跟踪管理系统，可以被企业管理人员，项目管理人员，开发人员，分析人员， 测试人员和其他人员所广泛使用。 2.3.1管理人员根据JIRA系统提供的数据，更加准确地了解项目的开发质量和状态，以及整个团队的工作效率。 2.3.2项目管理者可以针对登记进JIRA系统中问题，进行评估，分配缺陷；还可以通过JIRA系统的统计报告了解项目进展情况以及团队的工作量、工作效率等信息。 2.3.3开发人员在JIRA系统中查看分配给自己的问题，及时进行处理，填写处理情况并提交工作量记录。 2.3.4 测试人员根据测试情况，在JIRA系统中及时快速的记录问题并对开发人员处理后的问题进行验证和跟踪。 第三章、安装JIRAJIRA系统是一个&#39;web应用&#39;，就是说JIRA是需要安装到服务器上运行，客户端在自己的计算机上通过 web浏览器（如：IE）来访问JIRA。因此安装JIRA的需要条件主要是和服务器有关。 3.1安装Standalone发布包Standalone发布包集成了应用服务器（Tomcat）和HSQL数据库，仅需要Java环境，简单点儿说就是要安装JDK1.3以上版本；建议以前没有接触过JIRA的用户使用Standalone发布包。JIRA的Standalone发布包安装非常简单，您只需要从 http://www.fangwai.net/网站上下载最新的Standalone版本，然后解压缩到本地硬盘上（需要注意的是不要使用WinXP系统自带unzip功能），然后运行\bin目录下的startup.bat脚本文件就可以启动JIRA了。 运行startup脚本后，在web浏览器中访问： http://localhost:8080/然后根据浏览器界面上的JIRA配置向导，经过三个配置步骤就完成了： 第一个步骤是配置JIRA系统的属性；第二个步骤是配置JIRA系统管理员的信息； 第三个步骤是配置JIRA系统的邮件通知参数。 让我们在几分钟内就搭建好Standalone版本的JIRA，并运行在您的系统上。 在*标题输入中输入您安装的JIRA系统的标题信息； 在*模式下拉框中有两个选项：public和private。表示JIRA可以运行在两种模式下。Public模式－在这种模式下用户可以自己注册到JIRA系统中，并可以创建问题； Private模式－表示安装的JIRA系统是私有的，不允许用户随意注册，只能由JIRA系统管理员来创建用户、分配权限。 *根网址，表示您安装的JIRA系统的访问地址，用户在浏览器中通过这个URL来访问； &quot;*索引路径&quot;输入框中输入保存JIRA系统索引数据的目录,如：d:\jira\indexs Enable Backups，选择&quot;是&quot;启用JIRA系统的自动备份功能； &quot;附件路径&quot;输入框中输入保存与问题关联的附件文件的目录,如：d:\jira\attachments &quot;备份路径&quot;输入框中输入保存JIRA备份文件的目录,如：d:\jira\backups （JIRA提供了定期自动备份的功能，自动备份的文件就存储在这个目录下。） &quot;授权码&quot;输入框中输入评估license，如果没有的话，可以在安装界面上点击&quot;在线&quot;链接生成一个评估license，输入评估license后，点击&quot;下一步&quot;按钮开始第二步配置。 说明：您可能已经注意到了JIRA的安装界面右边有&quot;Choose Language&quot;列出了十几个国家的国旗图标，表示JIRA系统目前支持的语言种类，中文是默认的安装语言，如果您希望安装完成后，JIRA系统的用户界面是其他语言，那您可以在此选择一下。值得一提的是在安装完成后，用户也可以根据自己的需要和喜好，通过修改自己的配置参数来改变JIRA界面的显示语言，不影响其他用户的界面显示语言。 分别输入JIRA系统管理员的登录用户名、密码、全称以及管理员的邮件地址。然后点击&quot;下一步&quot;按钮进入第三步的配置。 您可以根据具体情况填写邮件通知的配置信息。如果您不希望JIRA系统与邮件系统集成来提供邮件通知功能，那么您可以点击&quot;禁止邮件通知&quot;按钮。 在网址输入框中输入邮件服务器的域名或者IP地址，如：smtp.fangwai.net SMTP端口通常填写为25（这个邮件服务器发送邮件的默认端口）； 用户名输入框中填写一个邮件的帐号，如：plum 密码输入框中填写与上面邮件帐号对应的密码。 然后点击&quot;完成&quot;按钮，结束JIRA的配置。 注：JIRA支持一个SMTP的邮件服务器以及若干个POP/IMAP邮件服务器。通过SMTP邮件服务器，JIRA会发邮件给订阅系统事件或者被分配Issue的用户。通过POP/IMPA邮件服务器，使用者可以通过email建立新的Issue或者对已有的Issue发表评论，非常方便，解决了许多项目团队中信息分散的问题。 3.2 浏览器要求JIRA支持各种主流的web浏览器，如：IE6、Mozilla、Firefox、Opera、Safari等。 3.3 操作系统要求JIRA的运行需要Java环境，Java是一个跨平台的编程语言，因此所有支持Java的操作系统上都可以运行JIRA，当然也需要考虑操作系统上是否支持您选择的应用服务器软件。目前Sun的JDK有 Windows(32位和64位)，Solaris（APARC 32位和64位）， Linux平台（32位和64位)。 3.4 JIRA支持的应用服务1)OrionServer2)Resin 3)Tomcat 4)JBoss 5)Jetty 6) Oracle OC4J 7)Weblogic 3.5 JIRA支持的数据库1)Oracle2)DB2 3) MySQL 4)Firebird 5) SQL Server 6)SapDB 7)PostgreSQL 8)Sybase 第四章、JIRA中的概念4.1问题JIRA跟踪问题（Issue），这些问题可以是 bug，功能请求或者任何其他您想要跟踪的的任务；每一个问题有一些关联的信息： -问题类型（Issue Type）-摘要（summary） -问题描述（description） -问题所属的项目 -问题关联的项目组件（component） -问题影响的项目版本（affect version） -问题将被解决的项目版本（resolved version） -问题发生的环境 -问题的优先级 -问题的报告者 -问题的指派处理人 -问题的当前状态 -问题相关的历史记录 4.1.1问题类型JIRA系统可以用于跟踪多种不同类型的问题。系统管理员可以根据需要添加。JIRA系统缺省提供的问题类型如下： Bug 测试过程、维护过程发现影响系统运行的缺陷New Feature 对系统提出的新功能Task 需要完成的任务Improvement 对现有系统功能的改进 4.1.2优先级（Priority Levels）在JIRA系统中用优先级来表示问题的严重级别。系统管理员可以在JIRA系统中添加优先级，JIRA系统缺省的优先级如下：Blocker 阻塞开发或测试的工作进度，或影响系统无法运行的错误Critical 系统崩溃，丢失数据或内存溢出等严重错误、或者必需完成的任务Major 主要的功能无效、新增功能建议Minor 功能部分无效或对现有系统的改进Trivial 拼写错误，文本未对齐等 4.1.3 状态（Status）每个问题有一个状态，用来表明问题所处的阶段，问题通过开始于open状态，然后开始处理/Progress，再到解决/Resolved，然后被关闭/Closed。根据情况的不同，您可以根据项目来定制问题状态以及工作流。JIRA系统提供的缺省状态如下： Open 表示问题被提交等待有人处理。In Progress 问题在处理当中，尚未完成。Resolved 问题曾解决，但解决结论未获认可，需要重新分派解决。Reopened 问题解决，等待结果确认，确认的结果是&quot;Reopened&quot;或者&quot;Closed&quot;。Closed 问题处理结果确认后，置于关闭状态。 4.1.4 解决（Resolutions）一个问题可以用多种方式解决，系统管理员是可以在JIRA系统中定制解决方式。JIRA系统默认的解决方式如下： Fixed 问题已经解决。 Won&#39;t Fix 问题未解决 - 将不会解决的问题。 Duplicate 重复的问题。 Incomplete 问题描述得不够准确、完全。 Cannot Reproduce 问题重现失败，或者无足够的信息重现问题。 4.2 项目一个JIRA系统通常包含许多项目。这些项目相当于产品或者开发项目，您想要跟踪和这些项目相关的问题。每一个问题属于一个项目。每一个项目有一个名字和一个关键字（如：WEB），以后属于这个项目的问题的关键字就会包含WEB（如：WEB-100，WEB-101）。值得注意的是，在JIRA系统中有一个权限&#39;Administer Projects&#39;，通常将这个权限赋给项目负责人，拥有这个权限的JIRA用户就可以管理项目的&#39;版本&#39;和&#39;组件&#39;。 4.2.1 项目版本在一个项目上，一般会有多个版本，如：1.0alpha、1.0beta、1.0、1.2、2.0。 JIRA系统中的问题涉及到两个版本字段：-影响版本，如一个bug可能影响版本1.1和1.2。 -修复版本，如bug影响版本1.1和1.2，可能在2.0版本上被解决。 版本通常有三种状态：发布/released、未发布/unreleased和归档/archived。版本还有发布日期，在特定的报告中会显示。在JIRA系统中可以为项目创建版本。 4.2.2 项目组件每一个项目通常会包含多个组件/模块，如：后台，GUI，邮件子系统等等。一个问题可以和组件关联起来。在JIRA系统中可以为项目添加组件。 4.3 分配给分配给/Assign To：把某个问题Issue指定给某个团队成员去解决； 4.4 上传附件或屏幕截图Attach file/Screenshot：附加文件或屏幕截图说明issue； 4.5 问题投票投票/Voting：除了问题的创建人，其他人可以用投票来表明支持某个问题的内容； 4.6 监视问题Watching：每人都有一个Watch List/监视列表，可以监视自己感兴趣的Issue的状态等。 第五章、使用JIRA5.1 登录和注册在成功安装配置完成后的界面上点击&quot;登录到JIRA&quot;,就会看到JIRA的登录界面了： 输入系统管理员的用户名和密码就可以登录JIRA系统。当然也可以点击&quot;注册&quot;链接在JIRA系统中注册另外的用户帐号。JIRA系统的注册帐号 输入系统管理员帐号信息后登录JIRA系统. 5.2 创建新项目现在可以算是正式开始使用JIRA了。在刚刚配置完的JIRA系统中是没有任何项目的，通常开始使用JIRA首先是创建项目，在上面的界面上点击&quot;现在创建一个项目&quot;，在界面上输入项目的名称，关键字/Key，项目负责人，项目的描述信息，通知模型/Notification Scheme，权限模型/Permission Scheme。最初使用的时候可以暂时不用管网址和Issue Security选项。Notification Scheme和/Permission Scheme可以分别选择JIRA系统缺省的Default Notification Scheme和Default Permission Scheme。 项目的信息填写完成后，点击&quot;增加&quot;按钮就会看到您在JIRA系统中创建的新项目的详细信息界面; 接下来，您可以在项目的详细信息界面上，为项目创建组件/模块（Components）,管理项目的版本。如要创建组件，可点击Component下方的&quot;Add&quot;链接，如要管理项目的版本（Versions），可点击Versions下面的&quot;Manage&quot;链接。 注意：新项目创建完成后，项目的关键字/key（如：上面界面图中项目的Key：KM）是不能修改的。 如果您想要继续创建新项目，则可以点击左侧的&quot;项目&quot;链接，然后再点击&quot;Add Project&quot;链接。 5.3 创建项目类别在使用JIRA过程中，会有越来越多的项目被添加到JIRA系统中，这时候可以利用JIRA系统的项目类别功能（Project Categories），定义一些项目类别名称，然后将同类的项目归到一个类别里面，方便管理。 在项目详细信息界面上可以找到Project Category: 无 ( Select Category ) 点击&quot;Select Category&quot;链接，选择一个项目类别，这样就把该项目添加到所选择的项目类别里了。把项目添加到项目类别后，在JIRA系统的首页上可以看到的效果; 5.4 添加用户在安装完JIRA系统后，系统中只有一个系统管理员帐号；在创建完项目后，通常需要在JIRA系统中添加其他的用户帐号，在管理界面上点击左侧的Users&amp;Groups-&gt;&quot;User Browser&quot;链接，在User Browser界面上再点击&quot;Add User&quot;链接就可以添加新用户了。注意：不要使用汉字作为用户名。 5.5 添加组JIRA系统的用户是通过Group来管理的，通过给组的授权，达到管理用户的目的。添加组的步骤： 在管理界面上点击左侧的Users&amp;Groups-&gt;&quot;Group Browser&quot;链接，在Group Browser界面右侧名称输入框中输入组名，然后点击&quot;Add Group&quot;按钮即可。注意：不要使用汉字作为组名。 5.6 创建问题创建问题第一个步骤是选择项目和问题类型，然后点击&quot;下一步&quot;填写问题的详细信息。 创建问题的第二步，填写或选择创建的问题详细信息，主要包括：问题的概要描述、优先级、逾期日期、所属模块、问题影响的版本、问题修复的版本、分配给哪个人员、问题出现的环境描述、问题详细信息描述。填写完成后，点击&quot;创建&quot;按钮。 问题创建完成后，分配到问题的用户将会收到通知邮件，登录JIRA系统后，在分配给我的问题列表中点击问题链接后，在问题的详细信息界面上就可以进行根据可选工作流程进行操作。问题详细信息界面图如下，从图中可以看出这个目前对这个问题可以进行的操作有三个：开始进行、解决问题和关闭问题。 问题创建后，您除了可安装可选工作流程对问题进行处理外，还可以给问题上传附件，填写备注，复制和编辑问题，如果有权限的话，还可以删除问题，创建子任务等。 5.7 浏览项目在浏览项目的界面上可以看到项目的基本信息资料，模块和版本信息及问题分布情况。 5.8 查找问题在查找问题界面上，您可以在界面左侧进行查询条件的设置，JIRA提供了强大的查询功能，在您设定好查询条件后，还可以将查询条件保存起来，定义为过滤器，供以后的重复使用，甚至可以将保存的过滤器共享给团队的其他成员。 第六章、项目设置6.1 添加项目 输入项目名称、项目缩写、项目经理，选择邮件通知方案和权限设置方案；参见5.2 6.2 添加项目模块在项目的详细信息界面上，为项目创建组件/模块（Components）,管理项目的版本。如要创建组件，可点击Components下方的&quot;Add&quot;链接。 6.3添加项目版本设置步骤如下： 在 Project 页面下的&quot; Versions &quot;部分，点击&quot; Manage &quot;Versions，进入管理版本界面，可以为项目添加版本、版本描述、设置发布日期。 6.4选择项目权限方案 设置步骤如下：1)点击&quot;管理&quot;－&quot;项目 &quot;，点击项目名称链查看项目详细信息界面；2)在&quot; Permission Scheme &quot;部分，点击&quot; 选择 &quot;链接，在进入的页面中选择需要的权限设置方案。 6.5 设置项目的 Default Assignee系统默认是分配给项目负责人，即项目经理。可以根据需要选择默认为模块负责人。 设置步骤如下：1)在 Project 页面下的&quot; Components &quot;部分，在&quot; select assignees for components &quot;处，点击&quot; Select &quot;链接，进入&quot; Select Component Assignee &quot;界面2)选择模块的默认分配人。 6.6 选择邮件通知方案设置步骤如下：1)选择&quot;管理&quot;－&quot; Projects &quot;－&quot; Projects &quot;，进入项目详细信息界面； 2)在&quot; Notification Scheme &quot;部分，点击&quot; select scheme &quot;链接，在进入的页面中选择需要的邮件通知方案。 第七章、JIRA系统的权限JIRA系统中的权限管理分为：系统级别、项目级别、问题级别以及注释级别。系统级是通过&quot;全局权限（Global Permissions）&quot;来管理的，影响JIRA系统中所有的项目和问题。针对个别项目来说，您还可以通过JIRA系统中的权限模型（Permission Scheme）进一步配置项目级别的权限。下面将分别介绍全局权限和基于项目的权限模型。 7.1 全局权限设置步骤：1) 以JIRA系统管理员登录系统；2) 点击&quot; Global Settings&quot;-&gt;&quot; Global Permissions&quot;。 7.2 系统缺省权限模型 如下是关于JIRA系统缺省权限模型中的权限描述： Administer Projects 管理项目的权限，能够管理项目的组件/components和版本/versions；通常将此权限分配给项目负责人。 Browse Projects 浏览项目；无此权限将无法浏览到JIRA系统中的项目；通常将此权限分配给项目组成员。 Create Issues 创建问题（报告bug）；通常将此权限分配给测试人员。 Edit Issues 编辑问题；拥有此权限可以对创建后的问题进行修改。通常将此权限分配给问题报告者、项目管理人员； Schedule Issues 设置或者编辑问题的预期完成日期；通常将此权限分配给问题报告者、项目管理人员； Move Issues 在项目之间移动问题；只能移动到有创建问题权限的项目上；通常将此权限分配给项目管理人员； Assign Issues 分配问题；通常将此权限分配给测试人员、项目管理人员。 Assignable User 可以分配到问题的人；通常将此权限分配给开发人员。 Resolve Issues 解决和重新打开问题，可以设置修复版本；通常将此权限分配给开发人员。 Close Issues 关闭问题；通常将此权限分配给问题报告人员或QA人员。 Modify Reporter 创建或编辑问题时修改报告者；通常将此权限分配给问题报告人员或项目管理人员。 Add Comments 添加注释；通常将此权限分配给项目组所有人员。 Delete Issues 删除问题、注释和附件；通常将此权限分配给问题报告人员或项目管理人员。 Work On Issues 针对问题做完成情况记录，须启用Time Tracking；通常将此权限分配给开发人员。 Link Issues 将相关问题链接到一起，须启用Issue Linking；通常将此权限分配给问题报告人员或项目管理人员。 Create Attachments 添加附件；通常将此权限分配给问题报告人员、开发人员和项目管理人员。 View Version Control 查看问题的提交版本控制信息；通常将此权限分配给问题报告人员、开发人员和项目管理人员。 View Voters and Watchers 查看投票者和关注者列表信息；通常将此权限分配给JIRA系统管理人员。 Manage Watcher List 管理问题监视者列表；通常将此权限分配给JIRA系统管理人员。 Set Issue Security 设置问题的安全级别,只有处于该安全级别的用户才可以看到问题。通常将此权限分配给JIRA系统管理人员。 第八章、常** 见问题 **与解答Q ：在哪里可以下载到 JIRA？A ：JIRA的官方下载URL：http://www.fangwai.net/software/jira/jiradownloadcenter.htm Q ：怎样能直接看到该缺陷，而不是必须先登录后可以看到该缺陷? A ：该问题有两种解决办法： 第一种是设置用户组 anyone 的权限为： Browse Projects ；第二种是在登录页面，将&quot;保持我在这台计算机的登录&quot;复选框选中。 Q ：JIRA能和源代码管理工具集成吗？ A ：能。JIRA系统中内置了与CVS集成的配置界面；另外JIRA还可以和SVN（Subversion）、Perforce。 Q ：JIRA能和MS VSS集成吗？A ：JIRA目前支持和VSS集成。 Q ：JIRA能和目录服务器集成进行用户登录认证吗？A ：能。如：JIRA可以和MS目录服务器（Active Directory）、OpenLDAP集成。 Q ：JIRA的扩展性如何？A ：JIRA具有很好的扩展性。Atlassian为开发者提供了丰富的&quot;资源&quot;，其中有开发文档和教程、插件开发工具箱、开发者邮件列表、插件库、JIRA API等等。]]></content>
      <categories>
        <category>JIRA</category>
      </categories>
      <tags>
        <tag>JIRA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - 3.6 学习(1)]]></title>
    <url>%2FPython%20-%203.6%20%E5%AD%A6%E4%B9%A0(1).html</url>
    <content type="text"><![CDATA[开始之前基础示例Python语法基础，python语法比较简单，采用缩紧方式。 print absolute value of a integera = 100 if a &gt;= 0: print(a) else: print(-a) 可以看到，注释以_#_开头，python的变量不需要任何前缀，行结束不需要结束符号，非常符合我们自然语言的阅读和书写习惯。当语句以:结尾时，缩紧的语句视为代码块。 Python是大小写敏感的，这一点需要特别注意。 输入与输出Python可以使用input()函数读取用户的输入，使用print()进行屏幕的输出。默认情况下，输入的内容为字符数据类型。 数据类型整数Python可以处理任意大小的整数，在程序中的表示方法和数学上的写法一模一样，可以使用0xff00的方式表示十六进制。 Python中使用_/进行除法运算，得到的结果是浮点数。使用//进行除法运算，得到的结果是整数。使用%_，表示取余数。 浮点数浮点数就是小数，可以使用数学写法，如：1.23,-9.01,也可以使用科学计数法表示，如：1.23e9,1.2e-5。 字符串字符串是使用_`_或&quot;括起来的任意文本。可以使用_*对特殊字符进行转义。可以使用r&#39;&#39;的形式，表示内部的字符串默认不进行转义。对于字符串内有换行等多行内容的，可以使用&#39;&#39;&#39;…&#39;&#39;&#39;的形式，多行字符前也可以加_r*。 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。以Unicode表示的str通过encode()方法可以编码为指定的bytes，如：&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)。反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法 在Python中，采用的格式化方式和C语言是一样的，如下:&gt;&gt;&gt; &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000) 布尔值布尔值：True、False。也可以用布尔代数表示：3 &gt; 2,* 3 &lt; 2_。布尔值的运算符号：and、_or_、_not*。 空值空值是Python里一个特殊的值，用None表示。 变量Python中的变量时动态变量，即变量的属性是在赋值的时候才决定的，变量名称必须是大小写英文、数字和*_*的组合，且不能用数字开头。Python中没有常量的概念，通常使用全部大写的变量来表示常量。 列表 listlist 是一种有序的集合，可以随时添加和删除其中的元素。用索引来访问list中每一个位置的元素，索引是从0开始的。当索引超出了范围时，Python会报一个IndexError错误。如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。 &gt;&gt;&gt; classmates = [&#39;Michael&#39;,&#39;Bob&#39;,&#39;Tracy&#39;] &gt;&gt;&gt; classmates [&#39;Michael&#39;,&#39;Bob&#39;,&#39;Tracy&#39;] &gt;&gt;&gt; len(classmates) 3 &gt;&gt;&gt; classmates[0] &#39;Michael&#39; &gt;&gt;&gt; classmates.append(&#39;Adam&#39;) #追加元素到末尾 &gt;&gt;&gt; classmates [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;] &gt;&gt;&gt; classmates.insert(1, &#39;Jack&#39;) #追加元素到指定位置 &gt;&gt;&gt; classmates [&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;] &gt;&gt;&gt; classmates.pop() #删除末尾的元素，使用pop(i)可以删除指定位置的元素 &#39;Adam&#39; &gt;&gt;&gt; classmates [&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] 元组 tulp元组 tulp 也是有序列表，与list的区别在于，一旦初始化就不能修改。没有append、insert等方法。tulp的定义方式如下： &gt;&gt;&gt; classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;) tulp 本身的元素不能发生变化，但是如果元素为list，那么list中的内容是可变的。 字典 dictdict 全称 dictionary ，在其他语言中称为 map，在PHP中其实就是 Array，使用键-值(Key-Value)的方式进行存储，具有极快的查找速度。使用范例 &gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} #dict的定义 &gt;&gt;&gt; d[&#39;Michael&#39;] #dict取值的方式 95 &gt;&gt;&gt; d[&#39;Adam&#39;] = 67 #dict设置新值的方式 &gt;&gt;&gt; &#39;Thomas&#39; in d #判断key是否存在 False &gt;&gt;&gt; d.get(&#39;Thomas&#39;) #get方式取值，如果不存在则返回None &gt;&gt;&gt; d.get(&#39;Thomas&#39;,-1)#指定不存在时的返回值 -1 &gt;&gt;&gt; d.pop(&#39;Bob&#39;) #删除某个key 75 setset和dict类似，也是一组key的集合，但不存储value。如下示例： &gt;&gt;&gt; s = set([1, 2, 3]) #初始化时提供一个list作为输入集合 &gt;&gt;&gt; s {1, 2, 3} &gt;&gt;&gt; s.add(4) #使用add方法添加元素 &gt;&gt;&gt; s {1, 2, 3, 4} &gt;&gt;&gt; s.remove(2) #使用remove方法 &gt;&gt;&gt; s {1, 3, 4} set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。 控制语句条件判断条件判断比较简单，主要是不要忘记写_:_，看看例子吧。 &gt;&gt;&gt; age = 3 &gt;&gt;&gt; if age &gt;= 18: … print(&#39;your age is&#39;, age) … print(&#39;adult&#39;) … else: … print(&#39;your age is&#39;, age) … print(&#39;teenager&#39;) … your age is 3 teenager 更多的条件判断。 &gt;&gt;&gt; age = 3 &gt;&gt;&gt; if age &gt;= 18: … print(&#39;adult&#39;) … elif age &gt;= 6: … print(&#39;teenager&#39;) … else: … print(&#39;kid&#39;) … kid 循环Python中的循环有两种，一种是for…in循环，依次把list或tulp中的每个元素迭代出来。 &gt;&gt;&gt; classmates [&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] &gt;&gt;&gt; for name in classmates: … print(name) … Michael Jack Bob Tracy 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。 sum = 0 n = 99 while n &gt; 0: sum = sum + n n = n - 2 print(sum) 跳出循环，可以使用 break 跳出循环。跳过本次循环,可以使用 continue 跳过本次循环，继续下一次循环。 函数调用函数Python中内置了很多函数，可以直接调用。在交互模式中，可以通过help(abs)查看函数的用法。 定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 示例如下： defmy_abs(x): if x &amp;gt;= 0: return x else: return -x 在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下。 返回多个值在其他语言中，一般只能返回一个值或者一个数组、对象，在Python中，可以通过tulp变通的返回多个值。 import math defmove(x, y, step, angle=0): nx = x + step \* math.cos(angle) ny = y - step \* math.sin(angle) return nx, ny &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(x, y) 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 位置参数Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 defpower(x): #x 就是一个位置参数 return x \* x defpower(x, n): #x,n都是位置参数 s = 1 while n &amp;gt; 0: n = n - 1 s = s \* x return s defpower(x, n＝2): #x,n都是位置参数，n设置了默认值 s = 1 while n &amp;gt; 0: n = n - 1 s = s \* x return s 有几点要注意：一是必选参数在前，默认参数在后，否则Python的解释器会报错二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。有多个默认参数时，调用的时候，既可以按顺序提供默认参数。也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。需要注意的是：默认参数必须指向不变对象！ 可变参数defcalc(*numbers): sum = 0 for n in numbers: sum = sum + n \* n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。 关键字参数关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 defperson(name, age, **kw): print(&amp;#39;name:&amp;#39;, name, &amp;#39;age:&amp;#39;, age, &amp;#39;other:&amp;#39;, kw) 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 #可以先组装出一个dict，然后，把该dict转换为关键字参数传进去 &gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} &gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=extra[&#39;city&#39;], job=extra[&#39;job&#39;]) name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} #简化的写法 &gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} &gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra) name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} extra表示把extra这个dict的所有key-value用关键字参数传入到函数的 kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命名关键字参数如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下。命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 defperson(name, age, *, city, job): print(name, age, city, job) &gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;) Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。 defperson(name, age, *args, city, job): print(name, age, args, city, job) 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 参考资料： 廖雪峰的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift - 开源框架总结]]></title>
    <url>%2FSwift%20-%20%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[苹果官方Swift文档《 The Swift Programming Language》 苹果开发者Swift文档及介绍 网友整理的Swift中文文档《 Apple Swift编程语言入门教程 》 中文版Apple官方Swift教程（Github协作翻译中） Apple Swift编程语言入门教程 Swift语言概览中文版 Swift英文文档markdown版 Swift开发视频教程【入门篇】 letsswift编译的Swift中文教程 Github上的Swift开源项目列表 国内第一个Swift社区： http://swift.sh/ &quot;轮子&quot;工具类 SwiftyJSON：GitHub上最为开发者认可的JSON解析类 swift：Swift版Lo-Dash(或underscore)函数式工具库 OAuthSwift：国外主流网站OAuth授权类库 PathKit：小而美的路径管理类 XCGLogger：功能完整的日志管理类库 Surge：基于苹果Accelerate高性能计算框架封装库 Async：简洁的后台执行代码封装库 Euler：直观、简洁的数学表达式∛27÷3+∑[3,1,2] LocationManager：地理位置管理封装库 Siren：当应用更新时，通知用户并提供App Store链接 BrightFutures：漫长或复杂计算由独立线程异步来完成 存储类 swift：简单、轻量，使用上最SQL的SQLite封装库 Realm：志向代替Core Data和SQLite的移动数据库 网络类 Alamofire：著名的AFNetworking网络基础库Swift语言版 starscream：WebSocket客户端类库 图片类 ImageScout：最小网络代价获得图片大小及类型 DominantColor：提取图片主色示例项目 Toucan：小而美的图片变换及处理类 gifu：高性能GIF显示类库 HanekeSwift：轻量带缓存高性能图片加载组件 界面类 animated-tab-bar：灵动的动画标签栏类库，storyboard中使用 SwiftForms：表单递交库，快速开发利器 BWWalkthrough：界面切换中加入灵动的动画效果 PNChart-Swift：带动画效果的图表控件库 SweetAlert-iOS：带动画效果弹窗封装类 AnimatedTabBar：灵动的动画标签栏类库 KYCircularProgress：简单、实用路径可定进程条 FloatLabelFields：Float Label Pattern浮动标签输入效果类 MapManager：地图及路径管理封装库 框架类 AsyncDisplayKit：提供界面的高流畅性切换及更灵敏的响应 Cartography：基于代码级的自动布局封装框架 MMWormhole：iOS扩展与宿主应用的通讯框架 NetworkObjects：轻量版HttpServer框架，跨平台解决方案 &quot;车子&quot;示例项目 LTMorphingLabel：特赞的文字飘入飘出效果 AEXML：简单又易于的XML解析类及示例 whereami：通过命令行获得当前设备地理位置 Design-Patterns：如何使用常用设计模式及示例 HamburgerButton-Menu/Close：无论 设计还是代码，都进行了精雕细琢 HamburgerButton-Menu/Back：对应 博文可知，开发者动画开发经验相当丰富 完整应用 - edhita：支持Markdown, HTML预览的文本编辑器 firefox-ios：来自Mozilla开发团队大型纯Swift项目 SwiftWeather：清新淡雅持续改进天气预报项目 VPNOn：驻在通知中心内的VPN开关应用]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo - 把word转成markdown]]></title>
    <url>%2FHexo%20-%20%E6%8A%8Aword%E8%BD%AC%E6%88%90markdown.html</url>
    <content type="text"><![CDATA[因为想用markdown写Hexo+Github发布博客（我的个人静态博客），而我的文档是word写的。 方案目前只研究了Mac下的方案： word-to-markdown，google用wordtomarkdown搜出来第一个，看来这个名字起得好。用这个的话得装个LibreOffice pandoc，这个就比较大名鼎鼎了 unoconv，介绍 首先尝试word-to-markdown我用google搜到的第一个就是这个了，当然要试试。 坑：Mac自带Ruby要玩gem，首先当然是上(Fan)套(Qiang)咯。连上vpn，然后： \$ gem install word-to-markdown 你以为这么一句话就能搞定了吗，那可真就太天真了。撞到最后一个premailer开始报对gem文件夹没有权限的错误，查了查，其实就是Mac版自带ruby版本的问题，不允许随便装东西，即便有sudo也不让。 网上的解决方案是开机安住CMD+R，把IntegrityProtection禁用，然后进系统装不能装的gem，然后再回去把它启用。这方案麻烦不说，其实还是在系统的gem库里加了也许就只会用那么一两次的不该加的东西，各种不安嘛，这方案明显不符合我的审美。 ok，那就rbenv走起吧求助万能的谷哥，提供了两种选择，rbenv或者rvm，看了一下，貌似rbenv更加的handoff，而且提供Homebrew安装，那就选它了。 \$ brew update \$ brew install rbenv 然后官方说是要运行rbenv init，运行一下说把下面这行加到.zshrc里去� eval \”\$(rbenv init -)\” 然后重启一下Terminal， # 看看装了些啥版本，system就是系统自带的了 \$ rbenv versions # 然后看看当前的版本 \$ rbenv version # 看看能装哪些版本 \$ rbenv install list 最后随便选了个2.3.0（其实也不是随便选的，我这人就爱最新版，但2.4.0还在dev，就选这个次新版了） \$ rbenv install 2.3.0 \$ rbenv global 2.3.0 这样就把ruby命令替换成rbenv管理的版本了，各种geminstall也不会报什么权限错误啊操作不允许之类的了。 速度重装word-to-markdown \$ gem install word-to-markdown 这次安装过程果然顺利，装完运行： \$ w2m 1.docx 我勒个去，转换结果直接输出到命令行了，而且也貌似并没有提供什么参数来指定输出文件，官方的意思就是：我输出到stdout了，剩下的你自己玩吧。 那就redirect一下吧 \$ w2m 1.docx > 1.md so easy嘛，顺便说说这个redicrect，有这么几种用法： system_profiler > file.txt > take the output of system_profiler and save it to the filefile.txt &amp;> The &amp; tells the shell to redirect the standard output andstandard error to the file. 2> If you want to just output standard error >> appending to the existing file 大名鼎鼎的Pandoc其实一开始只知道第一个方案，后来搜搜索的过程中居然发现大名鼎鼎的的Pandoc也是能干这个事情的， macOS安装（其他的系统看官网）：Youcan install pandoc using homebrew: brew install pandoc # Docx to markdown, including math: \$ pandoc -s example30.docx -t markdown -o example35.md 更多的Pandoc转换命令 对Table转换的表现由于其实要要写数据库设计文档，所以我主要是比较关注对Table的转换 word-to-markdown转出这么个玩意儿 | **名称** | **数据类型** | **默认值** | **说明**| **描述** | | --- | --- | --- | --- | --- | | id | int(11) | | 主键 | | | f\_classify\_id | tinyint(2) | | 一级分类id | act\_classify表的id | | s\_classify\_id | tinyint(2) | | 二级分类ID | | | count | int(11) | | 命中次数 | | | date | date | | 日期 | 单位：天 | 没细看源码，这种转换效果，估计对合并单元格的表格支持是有问题的（不过md的table本就不支持合并单单元格这么复杂的玩意儿），很明显的在不该换行的地方换行了。 Pandoc其实pandoc并不支持markdown里的table语法，只是吧表格转换成了一个视觉上的表格。 **名称** **数据类型** **默认值** **说明** **描述** ----------------- -------------------------- --------------------------------- id int(11) 主键 f\_classify\_id tinyint(2) 一级分类id act\_classify表的id s\_classify\_id tinyint(2) 二级分类ID count int(11) 命中次数 date date 日期 单位：天 这就有点尴尬了，不过其实标准的md语法并不支持table，好吧，就这么自我安慰好了。 结论 用word-to-markdown之后进一步手动编辑整理完善表格。 如果没什么特别要求，只是想把word转成markdown看看，然后看着更方便的话，pandoc对table的转换更具有可读性，对一些不支持table语法转换的markdown编辑器来说也更友好一些。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac - Hexo+GitHub轻松搭建自己的博客]]></title>
    <url>%2FMac%20-%20Hexo%2BGitHub%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档 传送门。Hexo的安装是个很快速简便的过程，但依然还是有不少坑。这里记录个我的安装过程( 这是我的Hexo+GitHub+Next+Markdown个人网站)，给大家一些参考。 整理一下安装流程： 1.hexo是基于nodejs的，需安装nodejs，安装nodejs最好选择homebrew 2.首先查看电脑是否安装ruby，因为homebrew安装依赖ruby 3.安装顺序：homebrew---->nodejs---->hexo 安装前提需要安装 Node.js 和 Git两个应用程序，直接到官网安装最新版本即可，如已安装请跳过。 Node.js官网 Git官网 安装Hexo安装完Node.js 及 Git 后，即可使用npm来安装Hexo： \$ npm install -g hexo-cli 初始化Hexo创建一个目录用来作为你的blog目录，例如MyBlog；并在该目录中进行Hexo的初始化： \$ hexo init MyBlog \$ cd ~/MyBlog/ \$ npm install 新建完成后，得到以下目录： · |-- _config.yml |-- package.json |-- scaffolds |-- source | |-- _drafts | |-- _posts |-- themes 至此，你就完成了Hexo的安装及初始化，接下来我们就可以进行本地的预览啦： \先安装hexo server \$ sudo npm install hexo-server 然后生成静态页面并打开hexo本地服务 \$ hexo generate (或 hexo g) \$ hexo server 按命令行提示，打开 http:\/\/localhost:4000\/即可看到默认主题的默认页面了。 \可能加载会很慢，因为默认主题中使用了些Google的资源，后面更换主题就会快很多了。 安装homebrew ruby -e \”\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\&quot; 安装nodejs brew install node 在安装nodejs过程中，提示如下警告： You have Xcode 8 installed without the CLT; 根据提示进行安装 安装hexo sudo npm install -g hexo 创建文件夹 mkdir blog cd blog hexo init 此时blog文件下出现了很多文件和文件夹 生成一套静态网页 hexo generate /** 生成一套静态网页 **/ hexo server /** 在服务器上运行 **/ 在浏览器上运行http://localhost:4000就能看到网站首页： 撰写博客 进入终端，使用cd命令进入到有Hexo框架的目录里面，输入： hexo new post \”我的第一篇博客\” 随后出现如下的消息： INFO Created: ~/blog/source/_posts/我的第一篇博客.md 证明创建文章成功，”我的第一篇博客”这个md文件会创建在source/_posts/的文件下。该md文件在自动生成时会带有一些属性： title: 定义了博文的标题 date: 定义了创作博文的时间 tags: 定义了博文的标签 除了这个三个属性以外我们还可以扩展一些属性： update: 定义了最后修改的时间 comments：定义能否评论此博文(默认为true) categories: 定义了博文的种类 配置文件 -- _config.yml说明 Hexo的每一个功能的配置文件都是_config.yml， 具体说明看下面的注解： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site ##修改以适应搜索引擎的收录 title: Hexo ##定义网站的标题 subtitle: ##定义网站的副标题 description: ##定义网站的描述 author: jason jwl ##定义网站的负责人 language: ##定义网站的语言,默认zh-Hans timezone: ##定义网站的时区 # URL ## If your site is put in a subdirectory, set url as \’http://yoursite.com/child\&#39; and root as \’/child/\’ url: http://yoursite.com ##定义网站访问的域名 root: / ##定义所在Web文件夹在哪个目录 permalink: :year/:month/:day/:title/ ##定义时间格式 permalink_defaults: # Directory source_dir: source ##定义从哪个文件夹获取博客资料 public_dir: public ##定义生成静态网站到哪个文件夹 archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/\#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 ##定义每一页多少条博客 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape ##定义使用的主题 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 注意： 另外修改这些属性时，请注意格式，属性和值要空一个格，比如theme:landscape。 hexo的基本配置以下是hexo配置文件 _config.yml 的基本内容及基本设置，更多个性化设置请参考官方文档： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site ##页面信息 title: Who\’s Blog ##标题，即浏览器标签栏显示的内容 subtitle: Why so serious? ##副标题 description: ##描述，简介 author: Charles Wei ##作者 language: zh-CN ##语言 timezone: Asia/Shanghai ##时区 # URL ## If your site is put in a subdirectory, set url as\’http://yoursite.com/child\&#39; and root as \’/child/\’ url: http://wwww.charleswei.me##域名，后面自定义域名后，写在这里，用.github.io的话，这里用默认的不用改 root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory ##文件目录，可不改 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing ##静态页面生成属性，可不改 new_post_name: :year-:month-:day-:title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag ##标签，可不改 default_category: uncategorized category_map: tag_map: # Date / Time format ##时间格式，可不改 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/\#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ##每页显示文章数，按需改 ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ##主题设置 ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: indigo # Deployment ##git部署关联 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github:https://github.com/glassweichao/glassweichao.github.io.git branch: master 主题配置Hexo具有高定制的主题效果，你可以从Hexo的主题库中选择合适的主题，也可以自己制作。 \以我现在使用的indigo主题为例。首先将主题库clone到MyBlog目录下的themes目录： git clone git\@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装less，主题使用less作为css预处理工具： npm install hexo-renderer-less --save 安装feed,用于生吃RSS： npm install hexo-generator-feed --save 安装json-content，用于生成静态站点数据，提供搜索功能的数据源： npm install hexo-generator-json-content --save 开启标签页： hexo new page tags 修改MyBlog/source/tags/index.md的源数据： layout: tags noDate: true comments: false --- 修改hexo配置文件_config.yml中的主题标签： theme: indigo 最后修改主题配置文件MyBlog/themes/indigo/_config.yml： #添加新菜单项遵循以下规则 # menu: # link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须 # text: About菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 # url: /about 链接，绝对或相对路径，必须。 # target: _blank 是否跳出，省略则在当前页面打开 menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/glassweichao target: _blank link: text: 测试 url: /404 rss: /atom.xml #你的头像,替换掉 indigo/source/img/logo.jpg 即可 urlavatar: /img/logo.jpg # Content tags: title: 标签 #是否开启分享 share: true #是否开启搜索 search: true #是否大屏幕下文章页隐藏导航 hideMenu: true #是否开启toc #toc: false 关闭toc toc: list_number: true # 是否显示数字排序 #浏览器标签栏小图标 favicon: /favicon.ico 本地同步github 在github上newRepository，并命名为xxxxx.github.io(xxxxx是你github的账号名)，然后把本地项目提交到github的远程项目。然后在浏览器上输入xxxxx.github.io就能访问自己的博客了。 同步到github，发现网站访问不了。经测试不是主题的问题。 个人建议不通过手动同步github，优先考虑通过修改_config.yml让hexo帮助我们同步github，方便快捷，配置如下所示： deploy: type: git repo: https://github.com/xxx/xxx.github.io.git( xxx为个人github的name) branch: master 配置完后，运行 hexo deploy 或者 hexo d 如出现以下的错误： ERROR Deployer not found: git 请运行以下命令进行安装： npm install hexo-deployer-git --save 再次运行hexo deploy。工程同步成功！ 与Github账户关联首先需要去Github注册一个账号，并新建一个名为[your_account].github.io 的仓库。 \然后打开前面创建的MyBlog目录下的 _config.yml 文件，在修改最下方的deploy为： \*注意，冒号后面一定要加空格 deploy: type: git repo: gihub:https://github.com/\[your\_account\]/\[your\_accout\].github.io.git branch: master 接下来安装hexo的git部署，在命令行中执行： \$ npm install hexo-deployer-git --save 最后，将生成静态页面并部署到github的仓库中，执行： \$ hexo d -g 或者 \$ hexo generate \$ hexo deploy 当提示 ** INFO Deploy done: git 即上传成功，这时就可以通过**http:\/\/[your_account].github.io 来访问你的个人站点了。 \这里涉及了github pages的相关内容，有兴趣的可以去了解一下。 当你增加新的文章或者插件时，可以通过以下几个命令进行同步操作： hexo clean hexo generate (hexo g) hexo deploy (hexo d) hexo server (hexo s)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - 自动化编译打包(Jenkins)]]></title>
    <url>%2FiOS%20-%20%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85(Jenkins).html</url>
    <content type="text"><![CDATA[从xcodebuild到shenzhen，再到Jenkins，完美演绎自动化操作。 Features xcodebuild自动构建命令 简介 构建 生成ipa文件 利用shenzhen进行打包 Jenkins自动化 安装 创建项目 构建 配置远程仓库 便捷设置 参考： xcodebuild自动构建命令 确保项目证书等配置都没问题，可以完美运行。 简介 首先说明下使用文档： man xcodebuild 基本上现在的包管理都是以pod来的，也就是以workspace的形式，所以基本的形式为： xcodebuild [-project projectname] [-target targetname ...] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [buildaction ...] [setting=value ...] [-userdefault=value ...] 解释两个参数： target，可以通过 xcodebuild -list 查看 configrtion，也可以通过 xcodebuild -list 查看 sdk，可用 xcodebuild -showsdks，一般默认就行 可以查看项目配置选项: xcodebuild -target Demo -configuration Debug -showBuildSettings 构建 基本的构建命令： xcodebuild -workspace Demo.xcworkspace -scheme Demo -configuration Debug -sdk iphoneos10.1 命令运行成功后会提示 ** BUILD SUCCEEDED**，一般会在项目目录下生成build文件夹,可以在里面看到你的生成的包。 对于workspace的形式来说，基本上也差不多： xcodebuild -workspace Demo.xcworkspace -scheme Demo -configuration Debug -sdk iphoneos10.1 好像对workspace构建后不会在项目目录下生成build文件夹，可以在你的命令后面添加SYMROOT=buildDir指定一个build文件夹）。 生成IPA文件 生成文件的命令是xrun： xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/Demo.app -o ~/Desktop/Demo.ipa 打包成功后，会在桌面找到你的ipa。 利用 shenzhen 进行打包 利用github上一个开源项目: shenzhen可以在命令行为ios项目进行打包并发布。具体安装步骤如下： gem install shenzhen 如果安装过程出现错误有可能是ruby的源找不到，可以到 RubyGems镜像改变ruby源。 如果还是出现问题可以更新下gem即可（sudo gem update）。 一切准备完毕就能在控制台上运行ipa命令了： \$ ipa Build and distribute iOS apps (.ipa files) Commands: build Create a new .ipa file for your app distribute:crashlytics Distribute an .ipa file over Crashlytics distribute:deploygate Distribute an .ipa file over deploygate distribute:fir Distribute an .ipa file over fir.im distribute:ftp Distribute an .ipa file over FTP distribute:hockeyapp Distribute an .ipa file over HockeyApp distribute:itunesconnect Upload an .ipa file to iTunes Connect distribute:pgyer Distribute an .ipa file over Pgyer distribute:rivierabuild Distribute an .ipa file over RivieraBuild distribute:s3 Distribute an .ipa file over Amazon S3 distribute:testfairy Distribute an .ipa file over TestFairy help Display global or [command] help documentation info Show mobile provisioning information about an .ipa file 可以看出通过bulid参数就能创建ipa文件，比如输入命令： ipa build 会直接在当前目录下生成ipa文件以及dSYM文件。 如果你的工程项目有很多targets，则ipabulid命令会列出现在所有targets，我们可以选择一个进行打包。 如简单的打包蒲公英事例： ipa distribute:pgyer -u USER_KEY -a APP_KEY iTunes Connect Distribution: ipa distribute:itunesconnect -a me\@email.com -p myitunesconnectpassword -i appleid --upload Jenkins自动化 安装 在 Mac 环境下，我们需要先安装 JDK，在Jenkins的官网下载最新的 war包。下载完成后，打开终端，进入到 war 包所在目录，执行以下命令： java -jar jenkins.war --httpPort=8080 #或简单的写法 java -jar jenkins.war 待Jenkins启动后，在浏览器中输出一下地址： http://localhost:8080 这样就打开Jenkins管理页面了。 基本界面Jenkins开始页面 创建项目 点击左上角的新建，或是店家开始创建一个新任务，出现下面的页面:Jenkins新建页面 这里输入的名字为Demo，并选择 构建一个自由风格的软件项目，点击OK进入到下一页面：Jenkins新建页面 其中这里在General中，点击高级，先使用本地项目做测试：Jenkins新建本地页面 源码管理暂选None，构建触发器和构建环境不需要选择：Jenkins新建本地页面 构建，选择shell形式，使用shenzhen来构建并直接上传到蒲公英:Jenkins使用shenzhen构建 其中，USER_KEY 和 API_KEY 可以在蒲公英的「账户设置」中找到，之后进行相应替换。 构建后的操作我们也不需要，直接点击保存。 构建 保存之后进入到项目工作目录，点击立即构建：Jenkins构建 会在构建历史中显示构建结构，点击进入查看：Jenkins 点击 Console Output 查看日志信息:Jenkins 会有一堆信息，成功的话会提示去蒲公英查看。 进入到蒲公英后台，会发现我们的应用已经发布上去，可以进行测试了。 配置远程仓库 首先配置SSH:Jenkins 创建global的类型：Jenkins 进去后点击左侧的 ` Add Credentials`:Jenkins 选择SSH类型，输入自己的用户名，PrivateKey 直接从 ~/.ssh 目录下读取就好。 工程的配置，跟本地的区别就是不需要配置自定义的工作空间，同时选择源码管理中的Git，填写对应的地址信息：Jenkins 然后其他的构建、查看过程都一致。 到蒲公英上检查，果然存在。完美！ 便捷设置 以上面的方式运行的Jenkins的，命令行是不能关闭的，为了方便的话，需要设置在后台运行： nohup java -jar jenkins.war &amp; 将命令写入到sh文件中，比如就叫start.sh，运行的时候直接跑脚本就好，附上文件内容： #!/bin/sh nohup java -jar /Users/home/Desktop/jenkinsWorkspace/jenkins/jenkins.war &amp; 同样的，关闭命令也可以直接使用，不过在使用关闭之前，需要下载个 jenkins-cli.jar文件： 首页 -> 系统管理 -> Jenkins CLI 里面同样包含好多其他命令，可以根据自己需要来调试。 设置关闭 Jenkins 的脚本： #!/bin/sh java -jar /Users/home/Documents/jenkins/jenkins-cli.jar -s http://localhost:8080/ shutdown 别忘记修改为自己的路径。 一般的命令可以直接在网址上体现出来，比如重启: http://localhost:8080/restart 上面既然用了iOS的打包，所以脚本感觉也是用swift来写也是比较配套的，在这里就不贴出来了，喜欢研究的童鞋就google一下~，我将之命名为begin.swift和end.swift，恩，感觉还是不错的 参考： iOS自动构建命令——xcodebuild 分享查询网 蒲公英]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS － 沙盒机制（SandBox)和获取沙盒路径]]></title>
    <url>%2FiOS%20-%20%E9%9B%86%E6%88%90Bundle%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8C%85.html</url>
    <content type="text"><![CDATA[iOSAPP可以在自己的沙盒里读写文件，但是，不可以访问其他APP的沙盒。每一个APP都是一个信息孤岛，相互是不可以进行通信的，唯独可以通过URLScheme。沙盒里面的文件可以是照片、声音文件、文本、属性列表等。 沙盒机制简介沙盒简述： 1，每一个APP都有一个存储空间，就是沙盒。 2，APP之间不能相互通信。 3，沙盒根目录结构：Documents、Library、temp。 简述一下Documents、Library、temp的区别： 1，Documents：用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。 2，Library：包含两个子目录：Caches和Preferences。Caches用来存放用户需要换成的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。 3，tmp：用于存放临时文件，这个可以放一些当APP退出后不再需要的文件。 打开模拟器沙盒方法方法一：前往文件夹打开 /Users/ligang/Library/Application Support/iPhone Simulator/ 直接在Finder-&gt;前往-&gt;前往文件夹，输入上面的内容即可。记住将ligang换成你的电脑用户名。 方法二：通过Finder一步步查找 模拟器上的APP的沙盒实在用户目录下的资源库里面，但是资源库是隐藏文件夹。所以查看沙盒之前，现将隐藏文件夹显示出来。显示隐藏文件的命令： defaults write com.apple.finder AppleShowAllFiles -bool true 用心的童鞋会发现，隐藏隐藏文件的命令： defaults write com.apple.finder AppleShowAllFiles -bool false 如何获取Documents、Library、tmp的路径？ 获取沙盒根目录获取沙盒根目录，直接调用NSHomeDirectory()： //获取沙盒根目录 NSString*directory=NSHomeDirectory(); NSLog(@&quot;directory:%@&quot;,directory); 控制台输出： 2017-05-10 09:23:57.708447+0800 VideoClip[408:70903] directory:/var/mobile/Containers/Data/Application/CC60BE19-540C-43BE-9F9C-293A2A630C9C 这个是真机的路径，大家有时间的话可以看看模拟器的根目录路径。 获取Documents路径获取Documents路径如下： //获取Documents路径 NSArray*paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString*path=[pathsobjectAtIndex:0]; NSLog(@&quot;path:%@&quot;,path); 控制台输出： 2017-05-10 09:23:57.708754+0800 VideoClip[408:70903] path:/var/mobile/Containers/Data/Application/Documents 获取Documents文件夹目录,第一个参数是说明获取Doucments文件夹目录，第二个参数说明是在当前应用沙盒中获取。 获取Library路径//获取Library路径 NSArray*paths=NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES); NSString*path=[pathsobjectAtIndex:0]; NSLog(@&quot;path：%@&quot;,path); 控制台输出： 2017-05-10 09:23:57.708754+0800 VideoClip[408:70903] path:/var/mobile/Containers/Data/Application/Library 获取Caches路径//获取Caches路径 NSArray*paths=NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES); NSString*path=[pathsobjectAtIndex:0]; NSLog(@&quot;path：%@&quot;,path); 控制台输出： 2017-05-10 09:23:57.708754+0800 VideoClip[408:70903] path:/var/mobile/Containers/Data/Application/Library/Caches 获取** tmp **路径NSString*tmp=NSTemporaryDirectory(); NSLog(@&quot;tmp：%@&quot;,tmp); 控制台输出： 2017-05-10 09:23:57.709190+0800 VideoClip[408:70903] tmp:/private/var/mobile/Containers/Data/Application/CC60BE19-540C-43BE-9F9C-293A2A630C9C/tmp/ 以上是iOS开发中获取沙盒路径的方法。 iOS 简单的存储和读取 本地图片 适用于 用户头像 //存储图片到本地沙盒 (void)saveImage:(UIImage *)image{ NSString *documentDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndexWithCheck:0]; NSString *imageName = [NSString stringWithFormat:@&quot;%@HeadImage&quot;,[USERDEFAULT objectForKey:USERNAME]]; NSString *filePath = [[documentDirectory stringByAppendingPathComponent:@&quot;HeadImages&quot;] stringByAppendingString:imageName]; NSData *data = UIImageJPEGRepresentation(image, 0.1); [data writeToFile:filePath atomically:YES]; } //获取本地沙盒存储的图片 (UIImage *)loadImage{ NSString *documentDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndexWithCheck:0]; NSString *imageName = [NSString stringWithFormat:@&quot;%@HeadImage&quot;,[USERDEFAULT objectForKey:USERNAME]]; NSString *filePath = [[documentDirectory stringByAppendingPathComponent:@&quot;HeadImages&quot;] stringByAppendingString:imageName]; NSFileManager *fm = [NSFileManager defaultManager]; if ([fm fileExistsAtPath:filePath]) { NSData \* data = [NSData dataWithContentsOfFile:filePath]; UIImage \*image = [UIImage imageWithData:data]; return image; } return nil; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SandBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - 开发代码部分规范]]></title>
    <url>%2FiOS%20-%20%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[1. 关于命名 1.1 统一要求 含义清楚，尽量做到不需要注释也能了解其作用，若做不到，就加注释 使用全称，不适用缩写 1.2 类的命名 大驼峰式命名：每个单词的首字母都采用大写字母 例子：MFHomePageViewController 后缀要求 a.ViewController: 使用ViewController做后缀 例子: MFHomeViewController b.View: 使用View做后缀 例子: MFAlertView c.UITableCell:使用Cell做后缀 例子: MFNewsCell d.Protocol: 使用Delegate或者DataSource作为后缀 例子: UITableViewDelegate 1.3 私有变量 小驼峰式命名：第一个单词以小写字母开始，后面的单词的首字母全部大写 例子：firstName、lastName 以 _ 开头，第一个单词首字母小写 例子：NSString * _somePrivateVariable 私有变量放在 .m 文件中声明 1.4 property变量 小驼峰式命名 例子：///注释 @property (nonatomic, copy) NSString *userName; 禁止使用synthesize关键词 1.5 宏命名 全部大写，单词间用 _ 分隔。[不带参数] 例子: #define THIS_IS_AN_MACRO @&quot;THIS_IS_AN_MACRO&quot; 以字母 k 开头，后面遵循大驼峰命名。[不带参数] 例子：#define kWidth self.frame.size.width 小驼峰命名。[带参数] #define getImageUrl(url) [NSURL URLWithString:[NSString stringWithFormat:@&quot;%@%@&quot;,kBaseUrl,url]] 1.6 Enum Enum类型的命名与类的命名规则一致 Enum中枚举内容的命名需要以该Enum类型名称开头 例子: typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) { AFNetworkReachabilityStatusUnknown = -1, AFNetworkReachabilityStatusNotReachable = 0, AFNetworkReachabilityStatusReachableViaWWAN = 1, AFNetworkReachabilityStatusReachableViaWiFi = 2 }; 1.7 Delegate命名 类的实例必须为回调方法的参数之一 例子:-(NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section 回调方法的参数只有类自己的情况，方法名要符合实际含义 例子: -(NSInteger)numberOfSectionsInTableView:(UITableView*)tableView 以类的名字开头(回调方法存在两个以上参数的情况)以表明此方法是属于哪个类的 例子:-(UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 使用did和will通知Delegate已经发生的变化或将要发生的变化, 例子:a.-(NSIndexPath*)tableView:(UITableView*)tableView willSelectRowAtIndexPath:(NSIndexPath*)indexPath;b.-(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath; 2. 私有方法及变量声明 2.1 声明位置 在.m文件中最上方，定义空的category进行声明 例子: #import &quot;CodeStandardViewController.h&quot;// 在这个category（类目）中定义变量和方法@interface CodeStandardViewController (){ // 声明私有变量 }// 私有方法 (void)samplePrivateMethod;@end@implementation CodeStandardViewController// 私有方法的实现 (void)samplePrivateMethod { //some code } 3.关于注释 最好的代码是不需要注释的 尽量通过合理的命名 良好的代码把含义表达清楚 在必要的地方添加注释 注释需要与代码同步更新 如果做不到命名尽量的见名知意的话，就可以适当的添加一些注释或者mark 3.1 属性注释 例子：/// 学生@property (nonatomic, strong) Student *student; 3.2 方法声明注释 /** * @brief 登录验证**@param personId 用户名*@param password 密码*@param complete 执行完毕的block**@return*/+ (void)loginWithPersonId:(NSString *)personId password:(NSString *)password complete:(void (^)(CheckLogon *result))complete; 4.关于UI布局 使用Interface Builder进行界面布局 Xib文件的命名与其对应的.h文件保持相同 Xib文件中控件的组织结构要合理，Xib文件中控件需要有合理的可读性强的命名，方便他人理解 5.格式化代码 5.1 指针 &quot;*&quot; 位置 定义一个对象时，指针 &quot;*&quot; 靠近变量 例子: NSString *userName; 5.2 方法的声明和定义 在- 、+和返回值之间留一个空格，方法名和第一个参数之间不留空格 - (id)initWithNibName:(NSString *)nibNameOrNilbundle:(NSBundle *)nibBundleOrNil{…} 5.3 代码缩进 使用 xcode 默认缩进，即 tab = 4空格 使用 xcode 中 re-indent 功能定期对代码格式进行整理 相同类型变量声明需要独行声明 例子: CGFloatoringX = frame.origin.x; CGFloatoringY = frame.origin.y; CGFloatlineWidth = frame.size.width; Method与Method之间空一行 例子: #pragma mark - private methods (void)samplePrivateMethod {…} (void)sampleForIf {…} 5.4 对method进行分组 使用 #pragma mark - 方式对类的方法进行分组 例子: #pragma mark - private methods (void)samplePrivateMethod {…} (void)sampleForIf {…} (void)sampleForWhile {…} (void)sampleForSwitch {…} (void)wrongExamples {…}#pragma mark - public methods (void)samplePublicMethodWithParam:(NSString*)sampleParam {…}#pragma mark - life cycle methods (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {…} (void)viewDidLoad {…} (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {…} 5.5 大括号写法 对于类的method: 左括号另起一行写(遵循苹果官方文档) (id)initWithNibName:(NSString *)nibNameOrNilbundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { // Custom initialization } return self; } 对于其他使用场景: 左括号跟在第一行后边 例子： - (void)sampleForIf { BOOL someCondition = YES; if(someCondition) { // do something here } } - (void)sampleForWhile { int i = 0; while (i &amp;lt; 10) { // do something here i = i + 1; } } - (void)sampleForSwitch { SampleEnum testEnum = SampleEnumTwo; switch(testEnum) { caseSampleEnumUndefined:{ // do something break; } caseSampleEnumOne:{ // do something break; } caseSampleEnumTwo:{ // do something break; } default:{ NSLog(@&amp;quot;WARNING: there is an enum type not handled properly!&amp;quot;); break; } } 任何需要写大括号的部分，不得省略 错误示例: - (void)wrongExamples { BOOLsomeCondition = YES; if (someCondition) NSLog(@&quot;this is wrong!!!&quot;); while(someCondition) NSLog(@&quot;this is wrong!!!&quot;); }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode常用代码块]]></title>
    <url>%2FXcode%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97.html</url>
    <content type="text"><![CDATA[Xcode的代码片段(CodeSnippets)创建自定义的代码片段，当你重用这些代码片段时，会给你带来很大的方便。 常用的： 1.strong： \@property (nonatomic,strong) \&lt;#Class#> *\&lt;#object#>; 2.weak： \@property (nonatomic,weak) \&lt;#Class#> *\&lt;#object#>; 3.copy： \@property (nonatomic,copy) NSString *\&lt;#string#>; 4.assign： \@property (nonatomic,assign) \&lt;#Class#> \&lt;#property#>; 5.delegate： \@property (nonatomic,weak) id\&lt;\&lt;#protocol#>> \&lt;#delegate#>; 6.block： \@property (nonatomic,copy) \&lt;#Block#> \&lt;#block#>; 7.mark： #pragma mark \&lt;#mark#> 8.ReUseCell： static NSString *rid=\&lt;#rid#>; \&lt;#Class#> *cell=[tableViewdequeueReusableCellWithIdentifier:rid]; if(cell==nil){ cell=[[\&lt;#Class#> alloc] initWithStyle:UITableViewCellStyleDefaultreuseIdentifier:rid]; } return cell; 9.MainGCD： dispatch_async(dispatch_get_main_queue(), \^{ \&lt;#code#> }); 10.AfterGCD： dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(\&lt;#delayInSeconds#> * NSEC_PER_SEC)),dispatch_get_main_queue(), \^{ \&lt;#code to be executed after a specified delay#> }); 11.OnceGCD： static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, \^{ \&lt;#code to be executed once#> }); 自定义代码片段： 以Strong为例： 1.在书写\@property属性的地方写下如下语句： \@property (nonatomic,strong) \&lt;#Class#> *\&lt;#object#>; 2.选中上述语句，用鼠标左键拖到指示的代码片段在Xcode中的区域里，就新建了一个代码片段 3.松开鼠标左键的同时，会弹出代码片段编辑窗口 图中从上到下的含义依次是： ①Title 代码片段的标题 ②Summary 代码片段的描述文字 ③Platform 可以使用代码片段的平台，有IOS/OS X/All三个选项 ④Language 可以在哪些语言中使用该代码片段 ⑤Completion Shortcut 代码片段的快捷方式，例：copy ⑥Completion Scopes 可以在哪些文件中使用当前代码片段，比如全部位置，头文件中等，当然可以添加多个支持的位置。 最后的一个大得空白区域是对代码片段的效果预览。 一切设置完成以后，点击该菜单右下角的Done按钮，新建工作就结束了。 代码片段备份： Xcode中的代码片段默认放在下面的目录中： ~/Library/Developer/Xcode/UserData/CodeSnippets]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程分解 假设两个有序表分别为a,b，最后归并到r表中。 归并过程：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 示例分解 假设原始序列为：{6，202，100，301，38，8，1}，其长度len = 7，归并过程： 1、第一次归并：先中分得到mid索引为3，递归归并左半部分{6， 202， 100，301}，对这个子序列又中分为{6, 202}和{100,301}，此时这两个子序列已有序；递归归并右半部分{38, 8,1}，对这个子序列又中分为{38, 8}和{1}，归并后形成{8，38}和{1}，共比较3次 2、第二次归并：第一次归并后变成{6,202},{100,301},{8,38},{1}，即{6，202，100，301，8，38，1}，再中分得到{6，202，100，301}和{8，38，1}，分别递归归并后为{6，100，202，301}新序列和{1，8，31}新序列，共比较3+1=4次。 3、第三次归并：第二次归并后，得到的两个有序的子序列为{6，100，202，301}和{1，8，38}，这一次是递归回到第一层了，已经是中分了，直接比较和复制到新的r即可。最终得到{1，6，8，38，100，202，301}，共比较4次（6与1比较，6与8比较，100与8比较，100与38比较）。 这个序列从无序到有序总共比较了3+4+4=11次。 算法复杂度分析 归并排序的效率是比较高的，假设数列长度为N，采用中分法的方式将数列分开成若干个小数列一共要log2N步，每步都是一个合并有序数列的过程，时间复杂度可以记为O ( N )，故一共为O( N * log2N)。 因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在常用的几种排序方法（快速排序，归并排序，希尔排序，堆排序）中也是效率比较高的。 时间复杂度：O ( N * log2N ) C语言实现 /** 归并排序算法 * @param list 待排序的序列 @param first 子序列的起点索引 @param last 子序列的终点索引 @param temp 临时数组，用于将两个子序列二路归并时存储 */ void mergeSort(int list[], int first, int last, int temp[]) { if (first &lt; last) { int mid = (first + last) / 2; // 递归归并中分左子序列，使子序列有序 mergeSort(list, first, mid, temp); // 递归归并中分右子序列，使子序列有序 mergeSort(list, mid + 1, last, temp); // 最后二路归并，使序列成有序 //必须明白的一点，每次中分递归归并都需要二路归并，因为中分后的任意子序列 // 在有序后，都要二路归并成一个序列 mergeList(list, first, mid, last, temp); } } /** 二路归并list[first…mid]子序列与list[mid+1…last] * @param list 序列 @param first 左子序列的起点 @param mid 序列中间分割点 @param last 右序列终点 @param temp 临时序列，用于将两个无序的子序列归并到temp中，使之有序 */ void mergeList(int list[], int first, int mid, int last, int temp[]){ int leftIndex = first; int leftEndIndex = mid; int rightIndex = mid + 1; int rightEndIndex = last; int tempIndex = 0; //寻找两个子序列，顺序遍历，将值小的复制到临时数组中，直到其中一个子序列遍历完毕 while (leftIndex &lt;= leftEndIndex &amp;&amp; rightIndex &lt;= rightEndIndex) { // 值小的就复制到临时数组中 if (list[leftIndex] &lt;= list[rightIndex]) { temp[tempIndex] = list[leftIndex]; tempIndex++; leftIndex++; } else { temp[tempIndex] = list[rightIndex]; tempIndex++; rightIndex++; } } // 有可能左子序列更长，因此将剩下的部分直接复制到临时数组中 while (leftIndex &lt;= leftEndIndex) { temp[tempIndex++] = list[leftIndex++]; } // 有可能右子序列更长，因此将剩下的部分直接复制到临时数组中 while (rightIndex &lt;= rightEndIndex) { temp[tempIndex++] = list[rightIndex++]; } // 最后还需要将有序的临时数组复制到原始序列中 for (int i = 0; i &lt; tempIndex; ++i) { list[first + i] = temp[i]; } // 这里添加一个打印，记录归并 NSMutableString *str = [[NSMutableString alloc] init]; for (int i = 0; i &lt; sizeof(list) - 1; ++i) { if (i == 0) { [str appendFormat:@”%d”, list[i]]; } else { [str appendFormat:@”, %d”, list[i]]; } } NSLog(@”此次二路归并后，得到的序列为：(%@)”, str); } 测试： int list[] = {6, 202, 100, 301, 38, 8, 1}; int temp[7] = {0}; mergeSort(list, 0, 7-1, temp); 打印效果： 此次二路归并后，得到的序列为：(6, 202, 100, 301, 38, 8, 1) 此次二路归并后，得到的序列为：(6, 202, 100, 301, 38, 8, 1) 此次二路归并后，得到的序列为：(6, 100, 202, 301, 38, 8, 1) 此次二路归并后，得到的序列为：(6, 100, 202, 301, 8, 38, 1) 此次二路归并后，得到的序列为：(6, 100, 202, 301, 1, 8, 38) 此次二路归并后，得到的序列为：(1, 6, 8, 38, 100, 202, 301) 从打印结果可以看出来，果然与我们前面的算法分析是一样的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。 最大堆的特性如下： 父结点的键值总是大于或者等于任何一个子节点的键值 每个结点的左子树和右子树都是一个最大堆 最小堆的特性如下： 父结点的键值总是小于或者等于任何一个子节点的键值 每个结点的左子树和右子树都是一个最小堆 算法思想 最大堆的算法思想是： 1、先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素 2、再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys≤ R[n-1].key 3、由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。 最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。 最小堆的算法思想是： 1、先将初始的R[0…n-1]建立成最小堆，此时是无序堆，而堆顶元素是最小的元素 2、再将堆顶R[0]与无序区的最后一个R[n-1]交换，由此得到新的无序堆R[0…n-2]和有序堆R[n-1]，且满足R[0…n-2].keys = R[n-1].key 3、由于交换后，前R[0…n-2]可能不满足最小堆的性质，因此再调整前R[0…n-2]为最小堆，直到只有R[0]最后一个元素才调整完成 最小堆排序完成后，其实是降序序列，每次调整堆都是要得到最小的一个元素，然后与当前无序堆的最后一个元素交换，所以所得到的序列是降序的。 提示：堆排序的过程，其实就是不断地扩大有序区，然后不断地缩小无序区，直到只有有序区的过程。 排序过程分析 因为算法比较抽象，这里直接通过举个小例子来说明堆排序的过程是如何的。下面我们用这个无序序列采用最大堆的进行堆排序，所得到的序列就是升序序列（ASC）。 无序序列：89,-7,999,-89,7,0,-888,7,-7 第一步：初始化建成最大堆： image 第二步：将堆顶最大元素999与无序区的最后一个元素交换，使999成为有序区。交换后，-7成为堆顶，由于-7并不是无序区中最大的元素，因此需要调整无序区，使无序区中最大值89成为堆顶，所以-7与89交换。交换后导致89的右子树不满足最大堆的性质，因此要对右子树调整成最大堆，所以-7要与0交换，如下图： image 从图中看到，当-7成89交换后，堆顶是最大元素了，但是-7的左孩子是0，右孩子是-888，由于-7&lt;0，导致-7这个结点不满足堆的性质，因此需要调整它。所以，0与-7交换。 然后不断重复着第二步的过程，直到全部成为有序区。 最后：所得到的是升序序列 image 时间复杂度 堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。 平均时间复杂度为：O( N * log2(N) ) 堆排序耗时的操作有：初始堆 + 反复调整堆，时间复杂度如下： 1、初始建堆：每个父节点会和左右子节点进行最多2次比较和1次交换，所以复杂度跟父节点个数有关。根据2x&lt;= n（x为n个元素可以折半的次数，也就是父节点个数），得出x = log2n。即O( log2n ) 2、反复调整堆：由于初始化堆过程中，会记录数组比较结果，所以堆排序对原序列的数组顺序并不敏感，最好情况和最坏情况差不多。需要抽取n-1 次堆顶元素，每次取堆顶元素都需要重建堆（O(重建堆) &lt;O(初始堆)）。所以小于 O(n-1) * O(log2n) 使用建议： 由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。 C语言实现 基于最大堆实现升序排序 // 初始化堆 void initHeap(int a[], int len) { // 从完全二叉树最后一个非子节点开始 // 在数组中第一个元素的索引是0 // 第n个元素的左孩子为2n+1，右孩子为2n+2， // 最后一个非子节点位置在(n - 1) / 2 for (int i = (len - 1) / 2; i &gt;= 0; –i) { adjustMaxHeap(a, len, i); } } void adjustMaxHeap(int a[], int len, int parentNodeIndex) { // 若只有一个元素，那么只能是堆顶元素，也没有必要再排序了 if (len &lt;= 1) { return; } // 记录比父节点大的左孩子或者右孩子的索引 int targetIndex = -1; // 获取左、右孩子的索引 int leftChildIndex = 2 * parentNodeIndex + 1; int rightChildIndex = 2 * parentNodeIndex + 2; // 没有左孩子 if (leftChildIndex &gt;= len) { return; } // 有左孩子，但是没有右孩子 if (rightChildIndex &gt;= len) { targetIndex = leftChildIndex; } // 有左孩子和右孩子 else { // 取左、右孩子两者中最大的一个 targetIndex = a[leftChildIndex] &gt; a[rightChildIndex] ?leftChildIndex : rightChildIndex; } // 只有孩子比父节点的值还要大，才需要交换 if (a[targetIndex] &gt; a[parentNodeIndex]) { int temp = a[targetIndex]; a[targetIndex] = a[parentNodeIndex]; a[parentNodeIndex] = temp; //交换完成后，有可能会导致a[targetIndex]结点所形成的子树不满足堆的条件， // 若不满足堆的条件，则调整之使之也成为堆 adjustMaxHeap(a, len, targetIndex); } } void heapSort(int a[], int len) { if (len &lt;= 1) { return; } // 初始堆成无序最大堆 initHeap(a, len); for (int i = len - 1; i &gt; 0; –i) { //将当前堆顶元素与最后一个元素交换，保证这一趟所查找到的堆顶元素与最后一个元素交换 // 注意：这里所说的最后不是a[len - 1]，而是每一趟的范围中最后一个元素 //为什么要加上&gt;0判断？每次不是说堆顶一定是最大值吗？没错，每一趟调整后，堆顶是最大值的 // 但是，由于len的范围不断地缩小，导致某些特殊的序列出现异常 // 比如说，5, 3, 8, 6,4序列，当调整i=1时，已经调整为3,4,5,6,8序列，已经有序了 // 但是导致了a[i]与a[0]交换，由于变成了4,3,5,6,8反而变成无序了! if (a[0] &gt; a[i]) { int temp = a[0]; a[0] = a[i]; a[i] = temp; } // 范围变成为： // 0…len-1 // 0…len-1-1 // 0…1 // 结束 //其中，0是堆顶，每次都是找出在指定的范围内比堆顶还大的元素，然后与堆顶元素交换 adjustMaxHeap(a, i - 1, 0); } } 基于最小堆实现降序排序 // 初始化堆 void initHeap(int a[], int len) { // 从完全二叉树最后一个非子节点开始 // 在数组中第一个元素的索引是0 // 第n个元素的左孩子为2n+1，右孩子为2n+2， // 最后一个非子节点位置在(n - 1) / 2 for (int i = (len - 1) / 2; i &gt;= 0; –i) { adjustMinHeap(a, len, i); } } void adjustMinHeap(int a[], int len, int parentNodeIndex) { // 若只有一个元素，那么只能是堆顶元素，也没有必要再排序了 if (len &lt;= 1) { return; } // 记录比父节点大的左孩子或者右孩子的索引 int targetIndex = -1; // 获取左、右孩子的索引 int leftChildIndex = 2 * parentNodeIndex + 1; int rightChildIndex = 2 * parentNodeIndex + 2; // 没有左孩子 if (leftChildIndex &gt;= len) { return; } // 有左孩子，但是没有右孩子 if (rightChildIndex &gt;= len) { targetIndex = leftChildIndex; } // 有左孩子和右孩子 else { // 取左、右孩子两者中最上的一个 targetIndex = a[leftChildIndex] &lt; a[rightChildIndex] ?leftChildIndex : rightChildIndex; } // 只有孩子比父节点的值还要小，才需要交换 if (a[targetIndex] &lt; a[parentNodeIndex]) { int temp = a[targetIndex]; a[targetIndex] = a[parentNodeIndex]; a[parentNodeIndex] = temp; //交换完成后，有可能会导致a[targetIndex]结点所形成的子树不满足堆的条件， // 若不满足堆的条件，则调整之使之也成为堆 adjustMinHeap(a, len, targetIndex); } } void heapSort(int a[], int len) { if (len &lt;= 1) { return; } // 初始堆成无序最小堆 initHeap(a, len); for (int i = len - 1; i &gt; 0; –i) { //将当前堆顶元素与最后一个元素交换，保证这一趟所查找到的堆顶元素与最后一个元素交换 // 注意：这里所说的最后不是a[len - 1]，而是每一趟的范围中最后一个元素 //为什么要加上&gt;0判断？每次不是说堆顶一定是最小值吗？没错，每一趟调整后，堆顶是最小值的 // 但是，由于len的范围不断地缩小，导致某些特殊的序列出现异常 // 比如说，5, 3, 8, 6,4序列，当调整i=1时，已经调整为3,4,5,6,8序列，已经有序了 // 但是导致了a[i]与a[0]交换，由于变成了4,3,5,6,8反而变成无序了! if (a[0] &lt; a[i]) { int temp = a[0]; a[0] = a[i]; a[i] = temp; } // 范围变成为： // 0…len-1 // 0…len-1-1 // 0…1 // 结束 //其中，0是堆顶，每次都是找出在指定的范围内比堆顶还小的元素，然后与堆顶元素交换 adjustMinHeap(a, i - 1, 0); } } C语言版测试 大家可以测试一下： // int a[] = {5, 3, 8, 6, 4}; int a[] = {89,-7,999,-89,7,0,-888,7,-7}; heapSort(a, sizeof(a) / sizeof(int)); for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i) { NSLog(@”%d”, a[i]); } Swift版实现 基于最大堆实现升序排序 func initHeap(inout a: [Int]) { for var i = (a.count - 1) / 2; i &gt;= 0; –i { adjustMaxHeap(&amp;a, len: a.count, parentNodeIndex: i) } } func adjustMaxHeap(inout a: [Int], len: Int, parentNodeIndex: Int) { // 如果len &lt;= 0，说明已经无序区已经缩小到0 guard len &gt; 1 else { return } // 父结点的左、右孩子的索引 let leftChildIndex = 2 * parentNodeIndex + 1 // 如果连左孩子都没有， 一定没有右孩子，说明已经不用再往下了 guard leftChildIndex &lt; len else { return } let rightChildIndex = 2 * parentNodeIndex + 2 // 用于记录需要与父结点交换的孩子的索引 var targetIndex = -1 // 若没有右孩子，但有左孩子，只能选择左孩子 if rightChildIndex &gt; len { targetIndex = leftChildIndex } else { // 左、右孩子都有，则需要找出最大的一个 targetIndex = a[leftChildIndex] &gt; a[rightChildIndex] ?leftChildIndex : rightChildIndex } // 只有孩子比父结点还要大，再需要交换 if a[targetIndex] &gt; a[parentNodeIndex] { let temp = a[targetIndex] a[targetIndex] = a[parentNodeIndex] a[parentNodeIndex] = temp //由于交换后，可能会破坏掉新的子树堆的性质，因此需要调整以a[targetIndex]为父结点的子树，使之满足堆的性质 adjustMaxHeap(&amp;a, len: len, parentNodeIndex: targetIndex) } } func maxHeapSort(inout a: [Int]) { guard a.count &gt; 1 else { return } initHeap(&amp;a) for var i = a.count - 1; i &gt; 0; –i { // 每一趟都将堆顶交换到指定范围内的最后一个位置 if a[0] &gt; a[i] { let temp = a[0] a[0] = a[i] a[i] = temp } print(a) print(i - 1) // 有序区长度+1，而无序区长度-1，继续缩小无序区，所以i-1 // 堆顶永远是在0号位置，所以父结点调整从堆顶开始就可以了 adjustMaxHeap(&amp;a, len: i - 1, parentNodeIndex: 0) print(a) } } 基于最小堆降序排序 func initHeap(inout a: [Int]) { for var i = (a.count - 1) / 2; i &gt;= 0; –i { adjustMinHeap(&amp;a, len: a.count, parentNodeIndex: i) } } func adjustMinHeap(inout a: [Int], len: Int, parentNodeIndex: Int) { // 如果len &lt;= 0，说明已经无序区已经缩小到0 guard len &gt; 1 else { return } // 父结点的左、右孩子的索引 let leftChildIndex = 2 * parentNodeIndex + 1 // 如果连左孩子都没有， 一定没有右孩子，说明已经不用再往下了 guard leftChildIndex &lt; len else { return } let rightChildIndex = 2 * parentNodeIndex + 2 // 用于记录需要与父结点交换的孩子的索引 var targetIndex = -1 // 若没有右孩子，但有左孩子，只能选择左孩子 if rightChildIndex &gt; len { targetIndex = leftChildIndex } else { // 左、右孩子都有，则需要找出最大的一个 targetIndex = a[leftChildIndex] &lt; a[rightChildIndex] ?leftChildIndex : rightChildIndex } // 只有孩子比父结点还要大，再需要交换 if a[targetIndex] &lt; a[parentNodeIndex] { let temp = a[targetIndex] a[targetIndex] = a[parentNodeIndex] a[parentNodeIndex] = temp //由于交换后，可能会破坏掉新的子树堆的性质，因此需要调整以a[targetIndex]为父结点的子树，使之满足堆的性质 adjustMinHeap(&amp;a, len: len, parentNodeIndex: targetIndex) } } func minHeapSort(inout a: [Int]) { guard a.count &gt; 1 else { return } initHeap(&amp;a) for var i = a.count - 1; i &gt; 0; –i { // 每一趟都将堆顶交换到指定范围内的最后一个位置 if a[0] &lt; a[i] { let temp = a[0] a[0] = a[i] a[i] = temp } else { return // 可以直接退出了，因为已经全部有序了 } // 有序区长度+1，而无序区长度-1，继续缩小无序区，所以i-1 // 堆顶永远是在0号位置，所以父结点调整从堆顶开始就可以了 adjustMinHeap(&amp;a, len: i - 1, parentNodeIndex: 0) } } 测试： var arr = [5, 3, 8, 6, 4] //var arr = [89,-7,999,-89,7,0,-888,7,-7] maxHeapSort(&amp;arr) print(arr) // 打印日志如下： [4, 6, 5, 3, 8] 3 [6, 4, 5, 3, 8] [3, 4, 5, 6, 8] 2 [5, 4, 3, 6, 8] [3, 4, 5, 6, 8] 1 [3, 4, 5, 6, 8] [3, 4, 5, 6, 8] 0 [3, 4, 5, 6, 8] [3, 4, 5, 6, 8]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[快速排序是在面试中经常问到的算法题，也比较难掌握，特别是没有经常写算法的人儿。 算法思想 用笔者所理解的话来说，其算法思想是利用分而治之的思想，每一趟都保证左边比基准小，右边比基准大，而且递归划分排序。 一趟快速排序的算法是： 1、设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2、以第一个数组元素作为基准数据，赋值给key，即key=A[0]； 3、从j开始向前搜索，即由后开始向前搜索(j减1)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4、从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5、重复第3、4步，直到i=j；(3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i，j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 举个例子： 1、对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，然后交换之并更新基准位置。 2、5,3,8,6,4用5作为比较的基准，right往左找，4&lt;5,找到了4，left往右找，8&gt;5，找到了8，然后交换，然后变成了5,3,4,6,8，同时新的基准位置修改为left，也就是4的位置，交换后变成4,3, 5, 6, 8，而新的基准位置就是5的位置了 3、4,3,5,6,8 然后以5为基准划分成两个小组（4, 3）和（5, 6,8），第一个小组和第二个小组分别进入到步骤1，最后形成（3，4）而（5，6，8）因为已经有序，所以整个过程就完成了。最终形成（3,4,5,6,8） 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 时间复杂度 快速排序是不稳定的，其时间平均时间复杂度是O ( nlgn )。 伪代码 void quickSort(int a[], int len, int left, int right) { // 所有都排序完毕了，就退出递归 if left &gt;= right { return; } // 每一趟划分，使左边的比基准小，右边的比基准大，并返回新的基准的位置 int baseIndex = partition(a, len, left, right); // 递归排序左部分 quickSort(a, len, left, baseIndex - 1); // 递归排序右部分 quickSort(a, len, baseIndex + 1, right) } int partition(int a[], int len, int left, int right) { // 记录哪个是基准数 int base = a[left]; // 记录当前基准数的位置 int baseIndex = left; while left &lt; right { // 先从右边往左边扫描，找到第一个比base还要小的数，但是不能与left相遇 while left &lt; right &amp;&amp; a[right] &gt;= base { right–; } // 再从左边往右边扫描，找到第一个比base还要大的数，但是不能与right相遇 while left &lt; right &amp;&amp; a[left] &lt;= base { left++; } // 将所扫描到的第一个比基准数小和第一个比基准数大的数交换 swap(a, left, right); } // 交换left与baseIndex对应的元素，将left位置的元素作为新的基准数 swap(a, baseIndex, left); // 返回新的基准位置 return left; } void swap(int a[], int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } C语言版 void quickSort(int a[], int len, int left, int right) { if (left &gt;= right) { return; } // 一次划分后，得到基准数据的位置 int baseIndex = partition(a, len, left, right); // 快排左边部分 quickSort(a, len, left, baseIndex - 1); // 快排右边部分 quickSort(a, len, baseIndex + 1, right); } int partition(int a[], int len, int left, int right) { // 每一次的划分，都让第一个元素作为基准 int base = a[left]; // 记下刚开始的基准的位置， 便于最后相遇时交换 int baseIndex = left; while (left &lt; right) { // 查找右部分比base还小的元素的下标 while (left &lt; right &amp;&amp; a[right] &gt;= base) { right–; } // 查找左部分比base还大的元素的下标 while (left &lt; right &amp;&amp; a[left] &lt;= base) { left++; } // 将这一趟比基准大和比基准小的所找到的第一个值，互相交换 swap(a, left, right); } // 在left与right相遇时，将基准数与相遇点交换 // 这样这一次划分，就可以保证左边的比基准数小，右边的比基准数大 swap(a, baseIndex, left); // 划分完成后，以left位置的元素作为新的基准，分成左右序列，分别递归排序 return left; } void swap(int a[], int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } Swift版 func quickSort(inout a: [Int], left: Int, right: Int) { if left &gt;= right { return } let baseIndex = partition(&amp;a, left: left, right: right) quickSort(&amp;a, left: left, right: baseIndex - 1) quickSort(&amp;a, left: baseIndex + 1, right: right) } func partition(inout a: [Int], var left: Int, var right: Int) -&gt;Int { let base = a[left] let baseIndex = left while left &lt; right { while left &lt; right &amp;&amp; a[right] &gt;= base { right– } while left &lt; right &amp;&amp; a[left] &lt;= base { left++ } swapInt(&amp;a, i: left, j: right) } swapInt(&amp;a, i: baseIndex, j: left) return left } func swapInt(inout a: [Int], i: Int, j: Int) { let temp = a[i] a[i] = a[j] a[j] = temp }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本篇来学习十大排序中的插入排序，学习其算法思想并尝试实现排序。 插入排序有两种：直接插入排序和折半插入排序。 直接插入排序 直接插入排序（4，3，1，2）的流程如下图： image 对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其过程大概是这样的： 第一个元素就认为是有序的，取第二个元素，判断是否大于第一个元素。若是大于，表示已经有序，不用移动，否则将已经有序的序列整体向后移动一个位置。依此类推，直到所有元素已经有序。 可以借助上面的图来理解。 时间复杂度 需要到两层循环来处理，外层循环用于跑多少趟，而内层循环用于移动元素位置，因此时间复杂度仍为O ( n2 ) 伪代码 void insertSort(int a[], int len) { for i = 1; i &lt; len; ++i { // 后者&gt;前者，才需要移动和插入 if a[i] &lt; a[i - 1] { // 记录下要移动的元素 int target = a[i]; // 将前j-1个有序的元素分别后移一个位置 int j = i; while j &gt; 0 &amp;&amp; a[j - 1] &gt; target { a[j] = a[j - 1]; j–; } // 将目标元素插入对应的位置，使之有序 a[j] = target; } } } C语言版 void insertSort(int a[], int len) { for (int i = 1; i &lt; len; ++i) { // 遇到不是有序的，才进入移动元素 if (a[i] &lt; a[i - 1]) { int target = a[i]; // 移动前j-1元素，分别向后移动一个位置 int j = i; while (j &gt; 0 &amp;&amp; a[j - 1] &gt; target) { a[j] = a[j - 1]; j–; } // 将目标元素放到目标位置，使之有序 a[j] = target; } } } OjbC版 (void)insertSort:(int[])a len:(int)len { for (int i = 1; i &lt; len; ++i) { // 遇到不是有序的，才进入移动元素 if (a[i] &lt; a[i - 1]) { int target = a[i]; // 移动前j-1元素，分别向后移动一个位置 int j = i; while (j &gt; 0 &amp;&amp; a[j - 1] &gt; target) { a[j] = a[j - 1]; j–; } // 将目标元素放到目标位置，使之有序 a[j] = target; } } } Swift版 func insertSort(var a: [Int]) -&gt;[Int] { for var i = 1; i &lt; a.count; ++i { if a[i] &lt; a[i - 1] { let target = a[i] var j = i while j &gt; 0 &amp;&amp; a[j - 1] &gt; target { a[j] = a[j - 1] j– } a[j] = target } } return a } 折半插入排序 从第二个元素开始逐个置入监视哨，使用low、high标签进行折半判断比较大小，并确认插入位置，该位置到最后一个数全部后移一位，然后腾出该位置，把监视哨里面的数置入该位置。依此类推进行排序，直到最后一个数比较完毕。 时间复杂度 折半插入排序, 即查找插入点的位置,可以使用折半查找，这样可以减少比较的次数,但是移动的次数不变，因此，时间复杂度仍为 O(n2) ; 伪代码 void binaryInsertSort(int a[], int len) { for int i = 2; i &lt; len; ++i { // 将元素放到哨兵的位置 a[0] = a[i]; int low = 1; int high = i - 1; // 折半查找位置 while low &lt;= high { int mid = (low + high) / 2; // 在低半区 if a[mid] &gt; a[0] { high = mid - 1; } else { // 在高半区 low = mid + 1; } } // 将前i - 1个元素后移 // 找到high，那么high+1就是i要插入的位置 for int j = i - 1; j &gt;= high + 1; –j { a[j + 1] = a[j]; } // 将临时放在岗哨的元素放到所查找到的位置处 a[high + 1] = a[0]; } } C语言版 void binaryInsertSort(int a[], int len) { for (int i = 2; i &lt; len; ++i) { // 第一个位置永远只是当作哨兵用 a[0] = a[i]; int low = 1; int high = i - 1; while (low &lt;= high) { int mid = (low + high) / 2; if (a[mid] &gt; a[0]) { high = mid - 1; } else { low = mid + 1; } } // 移动前i - 1个元素 for (int j = i - 1; j &gt;= high + 1; –j) { a[j + 1] = a[j]; } // 放到查找到的位置处 a[high + 1] = a[0]; } } Swift版 func binaryInsertSort(var a: [Int]) -&gt;[Int] { for var i = 2; i &lt; a.count; ++i { a[0] = a[i] var low = 1 var high = i - 1 while low &lt;= high { let mid = (low + high) / 2 if a[mid] &gt; a[0] { high = mid - 1 } else { low = mid + 1 } } for var j = i - 1; j &gt;= high + 1; –j { a[j + 1] = a[j] } a[high + 1] = a[0] } return a } 小结 对于折半插入排序算法，它需要一个哨兵，数组的0号位置是用作哨兵，而不存储数据。为什么所找到的位置是high+1呢？因为最后退出while循环一定是high= mid – 1之后，导致条件low &gt; high而退出。所以，最后所找到的位置一定是high = mid - 1，由于减了1，所以应该插入的位置是high + 1。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[一起来学习选择排序的算法，今天跟大家一起来学选择排序算法。将会使用C语言、ObjC和Swift分别来实现排序排序，并通过ObjC来举一个模型类选择排序的小例子，希望对大家在开发中应用算法有所帮助。 算法思想 选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。 算法思想：每一趟从前往后查找出值最小的索引（下标），最后通过比较是否需要交换。每一趟都将最小的元素交换到最前面。 举个例子：对5,3,8,6,4这个无序序列进行简单选择排序。 首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4。对剩下的序列依次进行选择和交换，最终就会得到一个有序序列。 其实选择排序可以看成是冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数，而比较次数是一样的。 注意：冒泡排序是从后往前扫，使大的往下沉，而小的往上浮；选择排序是从前往后扫，每趟找出值最小的索引，使每趟最小值都交换到该趟的最前面，从而得到升序序列。 其过程大概是这样的： 5, 3, 8, 6, 4（开始） 3, 5, 8, 6, 4（第一趟：将最小的3与5交换，使这一趟最小值3放到最前面） 3, 4, 8, 6, 5（第二趟：将最小的4与5交换，使这一趟最小值4放到最前面） 3, 4, 5, 6, 8（第三趟：将最小的5与8交换，使这一趟最小值5放到最前面） 3, 4, 5, 6, 8（第四趟：不需要交换，排序完成） 时间复杂度 选择排序可以看作冒泡排序的优化版本，一样要两层循环才能排序完成。 所以，选择排序的时间复杂度为O ( n2 ) 伪代码 void selectSort(int arr[], int len) { int min = 0; // 只需要n-1趟即可，到最后一趟只有一个元素，一定是最小的了 for i = 0; i &lt; len - 1; ++i { // 每一趟的开始，假设该趟的第一个元素是最小的 min = i; // 查找该趟有没有更小的，如果找到更小的，则更新最小值的下标 for j = i + 1; j &lt; len; ++j { if arr[j] &lt; arr[min] { min = j; } } // 如果该趟的第一个元素不是最小的，说明需要交换 if min != i { int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; } } } C语言版 void selectSort(int arr[], int len) { int min = 0; // 只需要n-1趟 for (int i = 0; i &lt; len - 1; ++i) { min = i; // 从第n+1趟起始找到末尾 for (int j = i + 1; j &lt; len; ++j) { // 找到比min位置更小的，就更新这一趟所找到的最小值的位置 if (arr[j] &lt; arr[min]) { min = j; } } // 如果min与i不相等，说明有比i位置更小的，所以需要交换 if (min != i) { int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; } } } ObjC版 (void)selectSort:(int [])arr len:(int)len { int min = 0; // 只需要n-1趟 for (int i = 0; i &lt; len - 1; ++i) { min = i; // 从第n+1趟起始找到末尾 for (int j = i + 1; j &lt; len; ++j) { // 找到比min位置更小的，就更新这一趟所找到的最小值的位置 if (arr[j] &lt; arr[min]) { min = j; } } // 如果min与i不相等，说明有比i位置更小的，所以需要交换 if (min != i) { int temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; } } } Swift版 func selectSort(var arr: [Int]) -&gt;[Int] { var min = 0 // 只需要n-1趟 for var i = 0; i &lt; arr.count - 1; ++i { min = i // 从第n+1趟起始找到末尾 for var j = i + 1; j &lt; arr.count; ++j { // 找到比min位置更小的，就更新这一趟所找到的最小值的位置 if arr[j] &lt; arr[min] { min = j } } // 如果min与i不相等，说明有比i位置更小的，所以需要交换 if min != i { let temp = arr[i] arr[i] = arr[min] arr[min] = temp } } return arr } 尝试ObjC实现模型选择排序 (void)selectSort:(NSMutableArray *)array { NSUInteger minIndex = 0; for (NSUInteger i = 0; i &lt; array.count - 1; ++i) { minIndex = i; for (NSUInteger j = i + 1; j &lt; array.count; ++j) { TestModel *modelj = [array objectAtIndex:j]; TestModel *model = [array objectAtIndex:minIndex]; // 比min下的还要小，则更新min if ([modelj.uid compare:model.uid options:NSCaseInsensitiveSearch] ==NSOrderedAscending) { minIndex = j; } } if (minIndex != i) { [array exchangeObjectAtIndex:minIndex withObjectAtIndex:i]; } } } 测试： NSMutableArray *array = [[NSMutableArray alloc] init]; for (NSUInteger i = 0; i &lt; 10; ++i) { TestModel *model = [[HYBTestModel alloc] init]; model.title = [NSString stringWithFormat:@”%ld”, 10 - (i + 1)]; model.uid = [NSString stringWithFormat:@”%ld”, 10 - (i + 1)]; [array addObject:model]; } [self selectSort:array]; for (TestModel *model in array) { NSLog(@”%@ %@”, model.uid, model.title); } // 打印:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本篇一起来学习冒泡排序的算法,今天跟大家一起来学冒泡排序算法。本篇将会使用C语言、ObjC和Swift分别来实现冒泡排序，并通过ObjC来举一个模型类冒泡排序的小例子，希望对大家在开发中应用算法有所帮助。 核心思想算法最讲究的就是算法的思想，只要将算法思想想明白了，就可以通过伪代码来写出算法，那么再使用对应的语言来实现就可以了。 冒泡排序的核心思想就是通过与相邻元素的比较和交换，把小的数交换到最前面。因为这个过程类似于水泡向上升一样，因此被命名为冒泡排序。 举个小例子：对5,3,8,6,4这个无序序列进行冒泡排序。 首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。 其过程大概是这样的： 第一趟： 5, 3, 8, 6, 4 （开始） 5, 3, 8, 4, 6 （6和4交换） 5, 3, 4, 8, 6 （8和4交换） 5, 3, 4, 8, 6 （3和4不用交换） 3, 5, 4, 8, 6 （5和3交换） 第二趟： 3, 5, 4, 6, 8 （8和6交换) 3, 5, 4, 6, 8 （4和6不用交换） 3, 4, 5, 6, 8 （5和4交换） 3, 4, 5, 6, 8 （3和4不用交换） 这里只需要两趟就可以排序完成了。 时间复杂度从算法思想可知，冒泡排序需要两个循环来控制遍历，也就是需要n * n趟才能判断、交换完成。 冒泡排序的时间复杂度为O(n2)。 伪代码void bubbleSort(int a[], int len) { for i = 0; i &lt; len - 1; i { for j = len - 1; j &gt; i; --j { if a[j] &lt; a[j - 1] { swap(a, j, j - 1); } } } } void swap(int a[], int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } C语言版void bubbleSortUsingC(int arr[], int len) { // 代表走多少趟，最后一趟就不用再走了 for (int i = 0; i &lt; len - 1; i) { // 从后往前走，相当于泡从水底冒出来到水面 for (int j = len - 1; j &gt; i; --j) { // 如果后面的比前面一个的值还要小，则需要交换 if (arr[j] &lt; arr[j - 1]) { swap(arr, j, j - 1); } } } } void swap(int arr[], int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 测试一下： int a[5] = {5,3,8,6,4}; bubbleSortUsingC(a, sizeof(a) / sizeof(int)); for (int i = 0; i &lt; sizeof(a) / sizeof(int); i) { NSLog(@&quot;%d&quot;, a[i]); } // 打印: 3, 4, 5, 6, 8 初步如期效果 ObjC版 (void)bubbleSort:(int [])array len:(size_t)len {for (size_t i = 0; i &lt; len - 1; i) { for (size_t j = len - 1; j &gt; i; –j) { if (array[j] &lt; array[j - 1]) { // 交换 int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; } }}} 测试使用： int a[5] = {5,3,8,6,4}; [self bubbleSort:a len:sizeof(a) / sizeof(int)]; for (int i = 0; i &lt; sizeof(a) / sizeof(int); i) { NSLog(@&quot;%d&quot;, a[i]); } Swift版 func bubbleSort(var arr: [Int]) -&gt;[Int] { // 走多少趟 for var i = 0; i &lt; arr.count - 1; i { // 从后往前 for var j = arr.count - 1; j &gt; i; –j { // 后者 &lt; 前者 ？ 交换 ： 不交换 if arr[j] &lt; arr[j - 1] { let temp = arr[j] arr[j] = arr[j - 1] arr[j - 1] = temp } } } return arr 测试使用： //由于swift中数组也是结构体，是值类型，因此需要接收返回值才能得到排序后的数组 var arr = [5, 3, 8, 6, 4] arr = bubbleSort(arr) print(arr) 尝试给Model排序 (void)bubbleSort:(NSMutableArray *)array { for (NSUInteger i = 0; i &lt; array.count - 1; i) { for (NSUInteger j = array.count - 1; j &gt; i; --j) { TestModel *modelj = [array objectAtIndex:j]; TestModel *modelj_1 = [array objectAtIndex:j - 1]; // 前者 &lt; 后者 ？ 交换 ：不交换 if ([modelj.uid compare:modelj_1.uid options:NSCaseInsensitiveSearch] == NSOrderedAscending) { [array exchangeObjectAtIndex:j withObjectAtIndex:j - 1]; } } } } 测试： NSMutableArray *array = [[NSMutableArray alloc] init]; for (NSUInteger i = 0; i &lt; 10; i) { TestModel *model = [[TestModel alloc] init]; model.title = [NSString stringWithFormat:@&quot;[公羽寒](http://cnblogs.com/gongyuhonglou)的技术博客：%ld&quot;, 10 - (i + 1)]; model.uid = [NSString stringWithFormat:@&quot;%ld&quot;, 10 - (i 1)]; [array addObject:model]; } [self bubbleSort:array]; for (TestModel *model in array) { NSLog(@&quot;%@%@&quot;, model.uid, model.title); } // 打印:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mavlink - 无人机通讯协议]]></title>
    <url>%2FMavlink%20-%20%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[http://qgroundcontrol.org/mavlink/start mavlink协议介绍 https://pixhawk.ethz.ch/mavlink/ 消息简介 MAVLink简介 Mavlink协议最早由 苏黎世联邦理工学院 计算机视觉与几何实验组 的 Lorenz Meier于2009年发布，并遵循LGPL开源协议。Mavlink协议是在串口通讯基础上的一种更高层的开源通讯协议，主要应用在微型飞行器（micro aerial vehicle）的通讯上。Mavlink是为小型飞行器和地面站（或者其他飞行器）通讯时常常用到的那些数据制定一种发送和接收的规则并加入了校验（checksum）功能。 协议以消息库的形式定义了参数传输的规则。MavLink协议支持无人固定翼飞行器、无人旋翼飞行器、无人车辆等多种类型的无人机。MAVLink协议是在CAN总线和SAE AS-4 标准的基础上设计形成的。 一 MAVLink所发送的数据结构 如图所示，每个消息帧都是上述的结构，除了灰色外，其他的格子都代表了一个字节的数据。灰色格子里面的数据长度是不固定的。 红色的是起始标志位（stx），在v1.0版本中以&quot;FE&quot;作为起始标志。这个标志位在mavlink消息帧接收端进行消息解码时有用处。 第二个格子代表的是灰色部分（payload，称作有效载荷，要用的数据在有效载荷里面）的字节长度（len），范围从0到255之间。在mavlink消息帧接收端可以用它和实际收到的有效载荷的长度比较，以验证有效载荷的长度是否正确。 第三个格子代表的是本次消息帧的序号（seq），每次发完一个消息，这个字节的内容会加1，加到255后会从0重新开始。这个序号用于mavlink消息帧接收端计算消息丢失比例用的，相当于是信号强度。 第四个格子代表了发送本条消息帧的设备的系统编号（sys），使用PIXHAWK刷PX4固件时默认的系统编号为1，用于mavlink消息帧接收端识别是哪个设备发来的消息。 第五个格子代表了发送本条消息帧的设备的单元编号（comp），使用PIXHAWK刷PX4固件时默认的单元编号为50，用于mavlink消息帧接收端识别是设备的哪个单元发来的消息（暂时没什么用） 。 第六个格子代表了有效载荷中消息包的编号（msg），注意它和序号是不同的，这个字节很重要，mavlink消息帧接收端要根据这个编号来确定有效载荷里到底放了什么消息包并根据编号选择对应的方式来处理有效载荷里的信息包。 最后两个字节是16位校验位，ckb是高八位，cka是低八位。校验码由crc16算法得到，算法将整个消息（从起始位开始到有效载荷结束，还要额外加上个MAVLINK_CRC_EXTRA字节）进行crc16计算，得出一个16位的校验码。之前提到的每种有效载荷里信息包（由消息包编号来表明是哪种消息包）会对应一个MAVLINK_CRC_EXTRA，这个 MAVLINK_CRC_EXTRA 是由生成mavlink代码的xml文件生成的，加入这个额外的东西是为了当飞行器和地面站使用不同版本的mavlink协议时，双方计算得到的校验码会不同，这样不同版本间的mavlink协议就不会在一起正常工作，避免了由于不同版本间通讯时带来的重大潜在问题。 为了方便叙述，消息包将称作包，包所代表的信息称作消息。上图中的sys将称为sysid，comp将称为compid，msg将称为msgid。 官方的介绍如下图： 上文中已经提到了在mavlink消息帧里最重要的两个东西，一个是msgid；一个是payload，前者是payload中内容的编号，后者则存放了消息。消息有许多种类型，在官网的网页中中以蓝色的&quot;#&quot;加数字的方式来表示消息的编号如 &quot;#0&quot;（这样的表示方法应该是为了方便在网页中查找相应编号消息的定义）。在官网介绍网页里往下拉，大概拉到二分之一的位置处，开始出现&quot;MAVLink Messages&quot;的介绍，往下看是各种消息的数据组成说明。 下面将以几个消息为例，讲解mavlink消息。 先以 #0 消息为例，这个消息叫心跳包（heartbeat）。它一般用来表明发出该消息的设备是活跃的，飞行器和地面站都会发出这个信号（一般以1Hz发送），地面站和飞行器会根据是否及时收到了心跳包来判断是否和飞行器或地面站失去了联系。 1.2 如图所示这是一个APM2.8的控制板输出的一帧心跳包数据，其固件是无人车的固件，可以详细的看到包开始标志，有效载荷长度，消息ID等等。从结构来讲还是比较简单的。这是一个心跳包的一帧数据，因为他的消息ID是00就代表这是一帧心跳包。 心跳包结构如下: 1.3 从图上可以看出，心跳包由6个数据组成 第一个参数是占一个字节的飞行器类型数据（type），这个数据表示了当前发消息的是什么飞行器，比如四旋翼，固定翼等等。type的取值如何与飞行器类型对应，Type表示设备类型在MAV_TYPE有定义可以在 https://pixhawk.ethz.ch/mavlink/ 的网页中搜索到，从图1.2可以看到，10是第一位的数据值，那么10在MAV_TYPE代表Ground rover(地面车辆)，这个数据就是从地面车辆的固件里面发出的。同理分析这9个字节所代表的含义可以知道心跳包所代表的含义。在上面网站的文档中可以分析到蓝色(#0,#1,#2) 这样的数据就是代表数据包。在文档的1/2处往后都可以看到，一共有254条消息类型，位于网页开始出的数据枚举中。如下图所示： 这里只是一部分的类型 第一个是通用飞行器，对应的type数值是0； 第二个是固定翼类型，对应的数值是1； 第三个对应的是四旋翼，对应的数值是2.这个飞行器类型，其实对于发心跳包的地面站来说可能没什么意义（不同飞控对该消息的处理方法不同，至少刷了PX4固件的Pixhawk飞控对地面站发来的心跳包里的这个参数并不关心，如无特殊说明，之后所说的Pixhawk飞控都是指刷PX4固件的飞控），对于飞行器端来说代表了当前飞行器的类型，地面站可以根据这个参数来判断飞行器的类型并作出其他的反应。 第二个参数是自驾仪（即通常所说的飞控）类型，比如apm，ppz，Pixhawk等飞控，具体定义查找和之前查找飞行器类型时的方法一样。同样的，对于发送心跳包的飞行器来说代表了自己的飞控类性，对地面站发出的心跳包来说意义不大。 第三个参数是基本模式（base mode），是指飞控现在处在哪个基本模式，对于发心跳包的地面站来说没有意义，对于发送心跳包的飞控来说是有意义的。这个参数要看各个飞控自己的定义方式，mavlink介绍网页并不会给出具体的模式。在Pixhawk中基本模式可以分为使用用户模式（custom mode）还是基本模式（这里有点绕，其实是就是是否使用用户模式）。使用用户模式将在讲下个参数时说明，使用基本模式又会分为自动模式（auto），位置控制模式（posctl）和手动模式（manual）。一般情况下都会使用用户模式，普通用户不用关心这个参数。开发者在使用mavlink修改飞行器模式时需要注意基本模式的设置，具体请看PX4代码， 下载地址 https://pixhawk.org/firmware/source_code 另外，Pixhawk的模式和apm的有很大的不同，具体请看官网介绍 https://pixhawk.org/users/system_modes 里面还有关于遥控器如何设置模式的教程链接 https://pixhawk.org/users/system_modes/mode_switch_config 用QGroundControl地面站（以后简称QGC，下载地址 http://qgroundcontrol.org/downloads ）的图形界面来设置飞行模式的功能很鸡肋，建议直接在QGC中读取飞控参数值，并对遥控器的设置参数进行修改，记得改变参数后只是改变了飞控ram参数，要把参数写入到rom中才可以。 第四个参数是用户模式（custom mode），大概说一下Pixhawk的用户模式。以多轴为例。它分为主模式（main mode）和子模式（sub mode），两种模式组合在一起成为最终的模式，主模式分为3种，手动（manual），辅助（assist），自动（auto）。手动模式类似apm的姿态模式。在辅助模式中，又分为高度控制模式（altctl）和位置控制模式（posctl）两个子模式，高度控制模式就类似apm的定高模式，油门对应到飞行器高度控制上。位置模式控制飞行器相对地面的速度，油门和高度控制模式一样，yaw轴控制和手动模式一样。自动模式里又分为3个子模式，任务模式（mission），留待模式（loiter），返航模式（return），任务模式就是执行设定好的航点任务，留待模式就是gps悬停模式，返航模式就是直线返回home点并自动降落。在apm里这个参数貌似是没有用的，注意这个数据占了4个字节，在Pixhawk中，前两个字节（低位）是保留的，没有用，第三个字节是主模式，第四个字节是子模式。普通用户请无视，开发者请注意：官网给出的通过程序设置模式的代码是错误的。如图，最后一行代码有误，应该为： uint32_t custom_mode = (main_mode&lt;&lt; 16) | (sub_mode &lt;&lt; 24); 第五个是系统状态（system status），查定义就好了，其中的standby状态在Pixhawk里就是还没解锁的状态，active状态就是已经解锁，准备起飞的状态。 第六个是mavlink版本（mavlink version），现在是&quot;3&quot;版本。 其余的消息也是类似的结构，各个数据的定义可以查看mavlink官方网页的说明，这些说明一般在网页的前面部分。具体说明以飞控为准，mavlink仅提供基本的定义。 有几个相对特殊和容易混淆的消息再特别说明下： 76消息（command long），该消息是发送长命令，一般是地面站发送给飞控命令用的。该消息组成如下图。目标系统（命令的接收方，就是目标系统编号sysid），目标单元（命令的接收单元，就是目标单元编号compid）。command数据是这条命令的编号，用于区别不同的命令。confirmation数据，笔者还不是很明白，大概是是否需要收到命令后回复确认信号的意思。接下去有七个参数，这些参数是执行这条命令所需要告诉飞控的，许多命令都用不到七个参数，多余的参数清0就可以了。 Pixhawk支持的命令有许多种（但不是所有mavlink命令都支持）。要看mavlink提供了哪些命令请在介绍mavlink的官网查询mav_cmd，在网页的中上部分。比如：第176号命令 MAV_CMD_DO_SET_MODE。这条命令用于改变飞行器的飞行模式，第一个参数就是设置飞控的base_mode，第二个是设置custom_mode。想要通过这条命令正确设置pixhawk的模式需要查看PX4代码，mavlink对参数的描述不够具体。 现在应该对介绍mavlink官网的布局有所了解了吧。网页前面主要讲了各类数据的取值和含义，比如飞控类型（mav_autopilot）,飞行器类型（mav_type）等，其中mav_cmd是比较特殊和重要的一种数据。网页的后半部分主要讲了mavlink消息的种类和数据组成，这里会用到各种数据，具体数据定义的可以回到前半部分去找。但是mavlink是个通用的通讯协议，不同的飞控支对mavlink支持方式不一样，一般都只支持一部分mavlink消息，还会自己扩展一些mavlink协议所没有定义的消息（pixhawk和apm都是如此），具体都以飞控代码为准。 二 地面站和飞控的通讯流程 由于没看过地面站的代码，所以很可能有误，还望发评论指正！一般飞控在连接上地面站后都会主动向地面站发送心跳包，飞行器姿态，系统状态，遥控器信号等组成的数据流。各个数据都会以一定的频率发送，比如心跳包一般是1Hz，姿态信息会快些，pixhawk用数传连接QGC时的姿态数据发送频率在7-8Hz左右。一般地面站会在刚连接上飞控时发送命令，请求飞控传回所有参数（QGC就是这样），飞控根据自己的情况判断是否接受地面站的请求，并根据不同的命令执行相应的操作（有些命令需要飞控回复地面站确认信号）。之后地面站根据用户的操作会发送相应的mavlink消息给飞控，比如设置航点，改写飞控参数等。据说数传是半双工的（在同一时刻只能选择发送或者选择接受数据，不能同时收发数据），地面站和飞控之间如何避免数据冲突（即双方同时向对方发送消息）的机制笔者并不清楚，希望能抛砖引玉。 可以看到，里面有多个文件夹和几个头文件。pixhawk，ardupilotmega（apm），matrixpilot这类的文件夹里都是各个飞控自己定义的mavlink消息类型 原始的mavlink消息放在common文件夹里面（大部分消息都在common文件夹中）。checksum.h中存放的是计算校验码的代码。 mavlink_helper.h里面是将各个消息包补充完整（调用checksum.h中的函数计算校验码并补上消息帧的头，比如sysid和compid等）成为mavlink消息帧再发送。最主要的功能集中在这两个文件夹中。 mavlink_conversions.h里是dcm，欧拉角，四元数三种姿态表示方法之间的转换代码。 下面以发送心跳包（heartbeat）为例，说明下如何使用mavlink头文件来发送心跳包。首先打开common文件夹中的 mavlink_msg_heartbeat.h 头文件。这个头文件可以分为两部分，一部分用来打包、发送heartbeat消息，另一部分用来接收到heartbeat消息时解码消息。heartbeat.h定义了heartbeat消息对应的数据类型： typedef struct __mavlink_heartbeat_t { uint32\_t custom\_mode; ///&amp;lt; A bitfield for use for autopilot-specific flags. uint8\_t type; ///&amp;lt; Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV\_TYPE ENUM) uint8\_t autopilot; ///&amp;lt; Autopilot type / class. defined in MAV\_AUTOPILOT ENUM uint8\_t base\_mode; ///&amp;lt; System mode bitfield, see MAV\_MODE\_FLAG ENUM in mavlink/include/mavlink\_types.h uint8\_t system\_status; ///&amp;lt; System status flag, see MAV\_STATE ENUM uint8\_t mavlink\_version; ///&amp;lt; MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8\_t\_mavlink\_version } mavlink_heartbeat_t; 如果mavlink的发送方式可以使用（串口发送，函数接口也兼容），则可以调用 static inline void mavlink_msg_heartbeat_send(mavlink_channel_t chan, uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status) 其中的chan是channel的缩写，用于选择发送的串口或者usb口。type就是飞行器类型，其余参数不明的可以看看本博客的第一篇文章。 该函数功能是将传入的各个参数按照对应的格式放到heartbeat消息包中（即打包） 这个函数内部有一句预处理： #if MAVLINK_CRC_EXTRA 是说是否使用额外的crc校验字符（默认使用），详情请看第一篇博客中对于两个校验字节的说明。 函数中会调用函数 _mav_finalize_message_chan_send(chan, MAVLINK_MSG_ID_HEARTBEAT, buf, MAVLINK_MSG_ID_HEARTBEAT_LEN, MAVLINK_MSG_ID_HEARTBEAT_CRC); MAVLINK_MSG_ID_HEARTBEAT//这个是心跳包消息对应的编号 这里=0 MAVLINK_MSG_ID_HEARTBEAT_LEN//这个是心跳包的长度 注意这个长度仅仅是payload的长度，不包括帧的头尾。 MAVLINK_MSG_ID_HEARTBEAT_CRC//这个是heartbeat消息对应的额外的crc校验码 这里=50 这个函数位于mavlink_helper.h中，用于更新消息帧的编号（seq 每发送一帧加1）并将消息帧的头和计算校验码，使得成为完整的一个mavlink消息帧。最后调用串口发送函数进行消息帧的发送。 如果只是想将对应的心跳包参数按照心跳包的格式存放好，则可以只调用 static inline uint16_t mavlink_msg_heartbeat_pack(uint8_t system_id, uint8_t component_id, mavlink_message_t* msg, uint8_t type, uint8_t autopilot, uint8_t base_mode, uint32_t custom_mode, uint8_t system_status) 将参数打包为heartbeat消息帧，待之后使用。 解码消息帧时可以调用mavlink_helper.h中的 MAVLINK_HELPER uint8_t mavlink_parse_char(uint8_t chan, uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status) 它会将收到的字符一个个进行解码，会检验收到的校验码是否正确；有效载荷的长度小于最大长度并且和该消息的长度一致。如果一切顺利，将会得到解码到的消息，放在解码得到的消息帧类型中 typedef struct __mavlink_message { uint16\_t checksum; ///&amp;lt; sent at end of packet uint8\_t magic; ///&amp;lt; protocol magic marker uint8\_t len; ///&amp;lt; Length of payload uint8\_t seq; ///&amp;lt; Sequence of packet uint8\_t sysid; ///&amp;lt; ID of message sender system/aircraft uint8\_t compid; ///&amp;lt; ID of the message sender component uint8\_t msgid; ///&amp;lt; ID of message in payload uint64\_t payload64[(MAVLINK\_MAX\_PAYLOAD\_LEN+MAVLINK\_NUM\_CHECKSUM\_BYTES+7)/8]; } mavlink_message_t; 其中的magic是一帧的起始标志（FE=254），就是mavlink_stx的值。 其余的mavlink消息也是类似的，旧的mavlink代码中有些类型的消息类型可能会找不到，使用时要注意接受和发送方使用的mavlink版本是否兼容。common文件夹中的common.h里面包含了要用到的数据类型和所有消息的头文件，使用时直接包含进来即可。 消息包封装过程 以上各区域信息存在关联，当使用MavLink协议提供的方法封装消息包时，会根据所使用的MSG获取到该类别MSG消息的LEN信息，同时软件（地面站或飞行控制软件）会根据自身状态信息填写SYS、COMP。信息填写完毕生成数据包时，封装方法会自动添加STX，并在上一次发送消息包所使用的SEQ上加1作为本次发送的SEQ写入，当SEQ超过255时，会回到0并重新开始计数。CKA、CKB会在PAYLOAD信息写入后、封装完成之前，根据CRC[Fe1] （CyclicRedundancy Check）循环冗余校验码算法计算得出并自动写入包内。 也就是说，设定SYS和COMP并且正确调用MavLink所提供方法后，整个消息包的生成过程中仅有MSG和PAYLOAD两项内容需要用户关心，消息包封装过程如活动图所示。 消息包示例 本文开始提到MavLink使用消息库的形式定义传输规则，用户可以在在源码中查阅消息库的内容，此处使用Java语言下的消息库作为实例，以便更清晰地展示包结构（MavLink源码自带了多语言的生成器，可从源码中的xml文件转换为对应C，C++，Java等语言的MavLink协议包）。以下表格中，SEQ为计算得出，数值不固定，故用X代替，SYS，COMP两项为笔者使用的Mission Planner地面站设定的系统ID和组件ID，MSG项0代表HEARTBEAT消息的ID，PAYLOAD内存储详细信息，最后的CKA CKB为封包后计算得出，以Y代替。 msg_heartbeat：最基本的心跳信号包，周期性发送，用于确认地面站与无人机之间的连接是否有效。 msg_request_data_stream：数据流请求包，地面站使用该消息包向飞行控制软件提交数据流申请，飞行控制软件收到该消息后将按照设定的参数周期性返回消息包。 大概知道了mavlink协议之后呢，我们就可以用MAVLINK结合APM2.6来实现一个APM的地面站。参考Mission Planner的地面站，Mission Planner是采用C#言语，基于C#的易用性，我们也采用C#语言。不过在编写一个简版的地面站以前。我们可以参考Mission Planner的构架，我们可以安装好VS2013，编译一下Mission Planner源码，如果有能力，可以修改Mission Planner源码。MP地面站的编译方法已经在另一篇文章中详细讲述过，编译完了之后有个SimpleExample的简单代码例程在MP的源码中，我们可以分析下这简单的代码，这个简单的代码是引用了MAVLINK的库，具体位置在MissionPlanner-master\ExtLibs\Mavlink中，如果我们要用只要在新建的工程里面引用即可，知道MAVLINK是怎么解析的。 消息解析 分析过消息包的结构后，继续向消息包的内部探索，开始分析负载信息PAYLOAD 在消息库中，每条消息都作为一个类存在（Java版本），类中的注释文本详细地注明了每个成员变量代表的含义。这些成员变量不仅包括STX、SEQ这些包的描述信息，还包括封装入`PAYLOAD的各个参数。在消息类中，还包含了pack()打包方法和unpack() 解包方法，为地面站和飞行控制软件的开发、应用提供了接口。 负载信息PAYLOAD内，大部分数据以Byte类型存储，同时也存在float型、short型等类型。需要注意的是，在Java中byte类型有符号位，能够覆盖-128—127范围，而C中byte为无符号位，覆盖范围为0—255。这一类差异在MavLink提供的方法中已经得到了妥善处理，使用MavLink协议提供的方法封装信息时无需担心，但如果是自己写封包解包方法，需要注意解析后读取参数值的类型转换问题。 负载信息的长度和格式并不统一，这是由于不同类型的消息包所需要传递的参数不一致而形成的。通过自己编写的&quot;伪飞控&quot;向地面站发送消息并接收，可以从Mission Planner地面站获取一系列消息包。查询各消息包内PAYLOAD含义，翻译后得到如下文本。 `msg_request_data_stream：该消息的作用在上一章里已讲，现在读取其负载信息。 req_message_rate：该类型消息请求间隔，用于控制飞控板向地面站发送指定类型消息的频率。 target_system，target_component：目标系统ID，笔者使用的Pixhawk飞控板这两项参数为1，1。 req_stream_id：请求数据流ID。非常重要的属性！该参数将直接影响飞控板返回数据流内信息包的类型，数据流ID为11时可以周期性收到VFR_HUD消息包和GLOBAL_POSITION_INT消息包，分别储存了平视显示器所需数据和GPS信息。 start_stop：数据流开始发送或停止发送标识。设为1则代表开始发送该数据流。 其他消息包内容由控制台打印，挑选部分展示。 MAVLINK_MSG_ID_ATTITUDE -time_boot_ms:16777195 roll:0.021675825 pitch:0.012977336 yaw:1.3565465rollspeed:-8.172542E-5 pitchspeed:-3.5201595E-4 yawspeed:3.577727E-4 Attitude状态报告，包括滚转角、偏航角、俯仰角（及其速度）等信息。 MAVLINK_MSG_ID_VFR_HUD -airspeed:0.0 groundspeed:0.0 alt:-0.07 climb:0.02 heading:77 throttle:0 共有 64 字节 平视显示器数据 Head Up Display 地面站接收到数据： MAVLINK_MSG_ID_GLOBAL_POSITION_INT -time_boot_ms:16777215 lat:0 lon:0 alt:0 relative_alt:-70 vx:0 vy:0 vz:0hdg:7772 共有 36 字节 GPS定位信息 地面站接收到数据： MAVLINK_MSG_ID_SYS_STATUS -onboard_control_sensors_present:16776207onboard_control_sensors_enabled:16751631onboard_control_sensors_health:16776207 load:130 voltage_battery:0current_battery:-1 drop_rate_comm:0 errors_comm:0 errors_count1:0errors_count2:0 errors_count3:0 errors_count4:0 battery_remaining:-1 常规系统状态信息 onboard_control_sensors_present：以位掩码表示控制器及传感器的存在状态，16776207（十进制）= 111111111111110000001111（二进制） onboard_control_sensors_enabled：以位掩码表示控制器及传感器的启用状态，16751631（十进制）= 111111111001110000001111（二进制) onboard_control_sensors_health：以位掩码表示控制器及传感器处于可用状态还是存在错误。转换为二进制同上。 以上掩码信息中，第一位表示gyro陀螺仪，第二位表示accelerometer加速度计，第六位表示GPS……详情见MAV_SYS_STATUS文件。 Load： Maximum usage in percent of the mainloop time,主循环内时间的最大使用比例，1000表示100%，该值应保持小于1000。 voltage_battery:电池电压，单位毫伏特。 current_battery：当前电池（电流），单位毫安。-1表示飞控未测量。 drop_rate_comm：通信丢失百分比，1000表示100%。 errors_comm：通信错误 (UART, I2C, SPI, CAN)，丢包。 Errors_countX:Autopilot-specific errors,飞控特定错误，未知含义。 battery_remaining:剩余电量，1表示1%，-1：autopilot estimate the remainingbattery，飞控估计电量。 MAVLINK_MSG_ID_POWER_STATUS -Vcc:4962 Vservo:21 flags:4 Vcc：5V rail voltage in millivolts，5V轨道电压，单位为毫伏。 Vservo：servo rail voltage in millivolts，伺服（电机？）轨道电压，单位为毫伏。 Flags：power supply status flags，供电状态标识，4表示MAV_POWER_STATUS_USB_CONNECTED，USB供电。详见MAV_POWER_STATUS。 MAVLINK_MSG_ID_MEMINFO - brkval:0freemem:52240 位于Ardupilotmega包内，记录内存信息 Brkval：heap top，堆顶 Freemem：空闲内存大小，单位为字节。 MAVLINK_MSG_ID_MISSION_CURRENT -seq:0 声明当前活动任务项的序列号 MAVLINK_MSG_ID_GPS_RAW_INT -time_usec:0 lat:0 lon:0 alt:0 eph:0 epv:65535 vel:0 cog:0 fix_type:0satellites_visible:0 The global position, as returned by the Global PositioningSystem (GPS). This is NOT the global position estimate of the system, butrather a RAW sensor value. See message GLOBAL_POSITION for the global positionestimate. Coordinate frame is right-handed, Z-axis up (GPS frame) 全球定位，并非系统估计位置，而是RAW传感器值。（Raw Sensor 原始传感器？）——右手坐标系，Z轴向上。 time_usec：时间戳，单位为microseconds微秒。 Lat：Latitude (WGS84), in degrees * 1E7，纬度，单位为度数*10的7次方。 Lon：Longitude (WGS84), in degrees * 1E7，经度，单位为度数*10的7次方。 alt：Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up).Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.高度，单位为km，向上为正。注意所有GPS模块除了WGS84高度以外，均提供AMSL（平均海平面以上）高 度。 Eph：GPS HDOP （horizontal dilution of position） in cm (m*100). If unknown, set to: UINT16_MAX，GPS水平精度因子，单位为厘米。 Epv： GPS VDOP vertical dilution of position in cm (m*100). Ifunknown, set to: UINT16_MAX，GPS垂直精度因子，单位为厘米。 Vel： GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX，全球定位系统地速度，单位为百米每秒。 Cog：Course over ground (NOT heading, but direction of movement) indegrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX 实际航迹向，单位为百分之一度。 fix_type：0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK.GPS修正类型。 satellites_visible：卫星可见数，未知则填写255。 MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT- nav_roll:0.0 nav_pitch:0.0 alt_error:0.14554046 aspd_error:0.0xtrack_error:0.0 nav_bearing:77 target_bearing:0 wp_dist:0 Outputs of the APM navigation controller. The primary use ofthis message is to check the response and signs of the controller before actualflight and to assist with tuning controller parameters. APM导航控制器的输出，该信息主要功能为检查实飞前控制器的回复和信号，辅助调整控制参数。 nav_roll：当前所需的滚转角 …… alt_error：高度误差 aspd_error：当前空速误差 m/s xtrack_erro：Current crosstrack error on x-y plane in meters.当前x-y平面横向轨迹误差 单位m nav_bearing：Current desired heading in degrees.当前任务/目标方位单位度 target_bearing：Bearing to current MISSION/target in degrees.当前任务/目标方位单位度 wp_dist：Distance to active MISSION in meters就，至当前任务点的距离，单位为m 共有 147 字节 地面站接收到数据： MAVLINK_MSG_ID_RAW_IMU -time_usec:4287561674 xacc:11 yacc:-9 zacc:-995 xgyro:0 ygyro:0 zgyro:0 xmag:25ymag:-133 zmag:325 The RAW IMU readings for the usual 9DOF sensor setup. Thismessage should always contain the true raw values without any scaling to allowdata capture and system debugging. RAW IMU惯性测量单元此消息始终只包含原始信息 time_usec：时间戳 Xacc：X acceleration (raw) X轴向加速度 Yacc：Y acceleration (raw) Y轴向加速度 Zacc：Z acceleration (raw) Z轴向加速度 Xgyro： Angular speed around X axis (raw) X轴旋转角速度 Ygyro： Angular speed around Y axis (raw) Y轴旋转角速度 Zgyro： Angular speed around Z axis (raw) Z轴旋转角速度 Xmag：X Magnetic field (raw) X磁场 Ymag：Y Magnetic field (raw) Y磁场 Zmag：Z Magnetic field (raw) Z磁场 MAVLINK_MSG_ID_SCALED_IMU2 -time_boot_ms:16777099 xacc:21 yacc:-6 zacc:-986 xgyro:-2 ygyro:3 zgyro:-6xmag:0 ymag:0 zmag:0 The RAW IMU readings for secondary 9DOF sensor setup. Thismessage should contain the scaled values to the described units 各项参数含义同上 MAVLINK_MSG_ID_SCALED_PRESSURE -time_boot_ms:16777099 press_abs:959.9057 press_diff:-0.0509375 temperature:3720 The pressure readings for the typical setup of one absolute anddifferential pressure sensor. The units are as specified in each field.绝对压强和压差传感器的读数。 time_boot_ms：时间戳 press_abs：Absolute pressure (hectopascal)，绝对压强，单位百帕斯卡 press_diff：Differential pressure 1 (hectopascal)，压差，单位百帕斯卡 temperature：Temperature measurement (0.01 degrees celsius) 温度，单位为0.01摄氏温度 MAVLINK_MSG_ID_SERVO_OUTPUT_RAW -time_usec:4287561666 servo1_raw:1016 servo2_raw:1016 servo3_raw:1016servo4_raw:1016 servo5_raw:0 servo6_raw:0 servo7_raw:0 servo8_raw:0 port:0 The RAW values of the servo outputs (for RC input from theremote, use the RC_CHANNELS messages). The standard PPM modulation is asfollows: 1000 microseconds: 0%, 2000 microseconds: 100%. 伺服系统输出原始值，（远程RC输入使用RC_CHANNELS消息）标准PPM调制如下：1000微秒：0%，2000微秒100%。 time_usec：时间戳 servo1_raw：Servo output 1 value, in microseconds，伺服输出1的值，单位微秒。 …… Port：Servo output port (set of 8 outputs = 1 port). MostMAVs will just use one, but this allows to encode more than 8 servos. 伺服输出端口，多数MAV只使用一个端口，最多可支持8伺服的编码。 MAVLINK_MSG_ID_RC_CHANNELS_RAW -time_boot_ms:16777099 chan1_raw:0 chan2_raw:0 chan3_raw:0 chan4_raw:0chan5_raw:0 chan6_raw:0 chan7_raw:0 chan8_raw:0 port:0 rssi:0 The RAW values of the RC channels received. The standard PPMmodulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.Individual receivers/transmitters might violate this specification. RC通道接收的原始值，标准PPM调制如下：1000微秒：0%，2000微秒100%。不同接收器或转换器可能违反该规范。 time_usec：时间戳 chan1_raw:0 RC channel 1 value, in microseconds. A value ofUINT16_MAX implies the channel is unused.遥控通道1，单位为微秒。设为无符号位16位整数最大值表示该通道未使用。 …… port:0 Servo output port (set of 8 outputs = 1 port). Most MAVswill just use one, but this allows for more than 8 servos. rssi:0 Receive signal strength indicator, 0: 0%, 100: 100%, 255:invalid/unknown.接收信号强度指示器，最小为0，最大为100 MAVLINK_MSG_ID_AHRS -omegaIx:-3.326245E-5 omegaIy:-1.11720045E-4 omegaIz:-3.0743552E-4accel_weight:0.0 renorm_val:0.0 error_rp:0.0013528633 error_yaw:0.0010219128 Status of DCM attitude estimator omegaIx: X gyro drift estimate rad/s X轴方向陀螺仪漂移量 omegaIy: Y gyro drift estimate rad/s omegaIz: Z gyro drift estimate rad/s accel_weight: average accel_weight. 平均加速权重（？） renorm_val: average renormalisation value 平均重正化值（？） error_rp: average error_roll_pitch value ？ error_yaw: average error_yaw value ？ MAVLINK_MSG_ID_HWSTATUS - Vcc:4962I2Cerr:0 Status of key hardware 关键硬件状态 Vcc：board voltage (mV) 飞控电压 毫伏 I2Cerr：I2C error count I2C错误计数 MAVLINK_MSG_ID_SYSTEM_TIME -time_unix_usec:0 time_boot_ms:16777100 The system time is the time of the master clock, typically thecomputer clock of the main onboard computer. 系统时间 time_unix_usec：Timestamp of the master clock in microseconds sinceUNIX epoch. 主时钟UNIX时间戳，1970-1-1 time_boot_ms：Timestamp of the component clock since boot time inmilliseconds. 自启动开始计时，时钟组件时间戳单位毫秒 MAVLINK解析示例 主代码如下： namespace SimpleExample { public partial class simpleexample : Form { MAVLink.MavlinkParse mavlink = new MAVLink.MavlinkParse();//MAVLINK解析包函数，通过这个函数从串口得到一帧的数据 bool armed = false; public simpleexample() { InitializeComponent(); } private void but\_connect\_Click(object sender, EventArgs e) { // if the port is open close it if (serialPort1.IsOpen) { serialPort1.Close(); return; } // set the comport options serialPort1.PortName = CMB\_comport.Text;//打开串口 serialPort1.BaudRate = int.Parse(cmb\_baudrate.Text); // open the comport serialPort1.Open(); // set timeout to 2 seconds serialPort1.ReadTimeout = 2000; // request streams - asume target is at 1,1 mavlink.GenerateMAVLinkPacket(MAVLink.MAVLINK\_MSG\_ID.REQUEST\_DATA\_STREAM, new MAVLink.mavlink\_request\_data\_stream\_t() { req\_message\_rate = 2, req\_stream\_id = (byte)MAVLink.MAV\_DATA\_STREAM.ALL start\_stop = 1, target\_component = 1, target\_system = 1 });//设置mavlink数据缓冲区格式 while (serialPort1.IsOpen) { try { // try read a hb packet from the compo var hb = readsomedata&amp;lt;MAVLink.mavlink\_heartbeat\_t&amp;gt;();//读取一帧心跳数据包 var att = readsomedata&amp;lt;MAVLink.mavlink\_attitude\_t&amp;gt;();//读取一帧姿态包 Console.WriteLine(att.pitch\*57.2958 + &amp;quot; &amp;quot; + att.roll\*57.2958);//写入命令行 } catch { } System.Threading.Thread.Sleep(1); Application.DoEvents(); } } T readsomedata&lt;T&gt;(int timeout = 2000)//读取数据函数 { DateTime deadline = DateTime.Now.AddMilliseconds(timeout); // read the current buffered bytes while (DateTime.Now &amp;lt; deadline) { var packet = mavlink.ReadPacketObj(serialPort1.BaseStream);//读出一帧数据 if (packet == null) continue; Console.WriteLine(packet);//打印在控制台 if (packet.GetType() == typeof(T)) { return (T)packet;//从一帧MAVLINK数据中返回T类型的数据，T类型是在调用处指定的可以是心跳包，或者姿态包等等。 } } throw new Exception(&amp;quot;No packet match found&amp;quot;); } MAVLink.MavlinkParse mavlink 最重要的是这个类，这个类是解析一帧数据包用的，我们来分析下 public partial class MAVLink { public static void ReadWithTimeout public byte[] ReadPacket public object ReadPacketObj//读取一包数据 public byte[] GenerateMAVLinkPacket//生成一个MAVLINK包，可以同个这个函数来生成读取数据包或者写命令数据包，在解析数据和读取MAVLINK数据之前都要先调用这个函数，生成一个空包，以便放入数据或者写入数据，相当于开辟一个MAVLINK数据缓冲区。 } 以上的程序运行如下： 图-读取MAVLINK数据包 可以看到在 var hb = readsomedata&lt;MAVLink.mavlink_heartbeat_t&gt;(); var att = readsomedata&lt;MAVLink.mavlink_attitude_t&gt;(); 在mavlink_heartbeat_t这个类中有心跳包的成员变量六个。 在MAVLink.mavlink_attitude_t这类中有姿态成员变量。我们可以在VS里面清楚的看到。所以如果我们想读取心跳包和姿态包，就可以使用上面的方法来获取心跳和姿态，很方便。通过上面的代码，我们就可以从APM的串口MAVLINK数据流中解析出想要的数据。我们想读取其他数据，在readsomedata中写入不同的形参即可，具体还有其他什么形参可以在VS里面查看。如果我们要更复杂的界面，做出专业的地面站，就去布局控件即可，不过还是比较复杂的，可以参考MP地面站。 UML图 绘制dependencyLibs的UML图。该包主要提供了MavLink的所有类型的封包类和解析类。 /** \* Encode this packet for transmission. \* \* @return Array with bytes to be transmitted \*/ public byte[] encodePacket() { byte[] buffer = new byte[6 + len + 2]; int i = 0; buffer[i++] = (byte) MAVLINK\_STX; buffer[i++] = (byte) len; buffer[i++] = (byte) seq; buffer[i++] = (byte) sysid; buffer[i++] = (byte) compid; buffer[i++] = (byte) msgid; final int payloadSize = payload.size(); for (int j = 0; j &amp;lt; payloadSize; j++) { buffer[i++] = payload.payload.get(j); } generateCRC(); buffer[i++] = (byte) (crc.getLSB()); buffer[i++] = (byte) (crc.getMSB()); return buffer; } 解包的核心部分在Parser类中： /** \* This is a convenience function which handles the complete MAVLink \* parsing. the function will parse one byte at a time and return the \* complete packet once it could be successfully decoded. Checksum and other \* failures will be silently ignored. \* \* @param c \* The char to parse \*/ public MAVLinkPacket mavlink\_parse\_char(int c) { msg\_received = false; switch (state) { case MAVLINK\_PARSE\_STATE\_UNINIT: case MAVLINK\_PARSE\_STATE\_IDLE: if (c == MAVLinkPacket.MAVLINK\_STX) { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_STX; } break; case MAVLINK\_PARSE\_STATE\_GOT\_STX: if (msg\_received) { msg\_received = false; state = MAV\_states.MAVLINK\_PARSE\_STATE\_IDLE; } else { m = new MAVLinkPacket(c); state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_LENGTH; } break; case MAVLINK\_PARSE\_STATE\_GOT\_LENGTH: m.seq = c; state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_SEQ; break; case MAVLINK\_PARSE\_STATE\_GOT\_SEQ: m.sysid = c; state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_SYSID; break; case MAVLINK\_PARSE\_STATE\_GOT\_SYSID: m.compid = c; state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_COMPID; break; case MAVLINK\_PARSE\_STATE\_GOT\_COMPID: m.msgid = c; if (m.len == 0) { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_PAYLOAD; } else { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_MSGID; } break; case MAVLINK\_PARSE\_STATE\_GOT\_MSGID: m.payload.add((byte) c); if (m.payloadIsFilled()) { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_PAYLOAD; } break; case MAVLINK\_PARSE\_STATE\_GOT\_PAYLOAD: m.generateCRC(); // Check first checksum byte if (c != m.crc.getLSB()) { msg\_received = false; state = MAV\_states.MAVLINK\_PARSE\_STATE\_IDLE; if (c == MAVLinkPacket.MAVLINK\_STX) { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_STX; m.crc.start\_checksum(); } stats.crcError(); } else { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_CRC1; } break; case MAVLINK\_PARSE\_STATE\_GOT\_CRC1: // Check second checksum byte if (c != m.crc.getMSB()) { msg\_received = false; state = MAV\_states.MAVLINK\_PARSE\_STATE\_IDLE; if (c == MAVLinkPacket.MAVLINK\_STX) { state = MAV\_states.MAVLINK\_PARSE\_STATE\_GOT\_STX; m.crc.start\_checksum(); } stats.crcError(); } else { // Successfully received the message stats.newPacket(m); msg\_received = true; state = MAV\_states.MAVLINK\_PARSE\_STATE\_IDLE; } break; } if (msg\_received) { return m; } else { return null; } } 这个类的使用是逐个直接解析，解析完毕后返回完整的包，例如，对字节数组packet，解析过程如下： for(int i = 0; i &lt; packet.length - 1; i++){ parser.mavlink\_parse\_char(packet[i] &amp;amp; 0xFF);//每次解析1位 } MAVLinkPacket m = parser.mavlink_parse_char(packet[packet.length - 1] &amp; 0xFF);//最后1位即可返回 MavLink包测试 dependencyLibs提供了测试实例。以msg_altitude为例，判断生成的包和解析的包是否相同，即可判断该类是否正确。 /** * The current system altitude. */ public class msg_altitude_test{ public static final int MAVLINK_MSG_ID_ALTITUDE = 141; public static final int MAVLINK_MSG_LENGTH = 24; private static final long serialVersionUID = MAVLINK_MSG_ID_ALTITUDE; private Parser parser = new Parser();//1位解析类 public CRC generateCRC(byte[] packet){ CRC crc = new CRC(); for (int i = 1; i &amp;lt; packet.length - 2; i++) { crc.update\_checksum(packet[i] &amp;amp; 0xFF); } crc.finish\_checksum(MAVLINK\_MSG\_ID\_ALTITUDE); return crc; } public byte[] generateTestPacket(){ ByteBuffer payload = ByteBuffer.allocate(6 + MAVLINK\_MSG\_LENGTH + 2); payload.put((byte)MAVLinkPacket.MAVLINK\_STX); //stx payload.put((byte)MAVLINK\_MSG\_LENGTH); //len payload.put((byte)0); //seq payload.put((byte)255); //sysid payload.put((byte)190); //comp id payload.put((byte)MAVLINK\_MSG\_ID\_ALTITUDE); //msg id payload.putFloat((float)17.0); //altitude\_monotonic payload.putFloat((float)45.0); //altitude\_amsl payload.putFloat((float)73.0); //altitude\_local payload.putFloat((float)101.0); //altitude\_relative payload.putFloat((float)129.0); //altitude\_terrain payload.putFloat((float)157.0); //bottom\_clearance CRC crc = generateCRC(payload.array()); payload.put((byte)crc.getLSB()); payload.put((byte)crc.getMSB()); return payload.array(); } @Test public void test(){ byte[] packet = generateTestPacket(); for(int i = 0; i &amp;lt; packet.length - 1; i++){ parser.mavlink\_parse\_char(packet[i] &amp;amp; 0xFF);//每次解析1位 } MAVLinkPacket m = parser.mavlink\_parse\_char(packet[packet.length - 1] &amp;amp; 0xFF);//最后1位即可返回 byte[] processedPacket = m.encodePacket();//解析 assertArrayEquals(&amp;quot;msg\_altitude&amp;quot;, processedPacket, packet); } } Mavlink 协议硬解析主要代码 int MAVLinkProtocol::ParseMsg(BYTE arMsgBuf[], MSGVALUE *pMavMsg, CString &amp;strMsgText) { // Function : // Parameters : arMsgBuf - 为完整的 mavlink msg 缓冲区, 从 0xFE 开始到 最后一个校验字节(CKB) // Return value: // Remark : int i, nOfst, nLenMaxPayload; BYTE nMsgID; char szTmpName[LEN\_MSGNM]; char szStatusTxt[MAVLINK\_MSG\_ID\_STATUSTEXT\_LEN]; char szValueID[MAVLINK\_MSG\_PARAM\_VALUE\_FIELD\_PARAM\_ID\_LEN]; CString strTmp, strUnicodeTmp; i = 0; nOfst = 0; if(arMsgBuf[0] != 0xfe) return -1; nMsgID = arMsgBuf[5]; ASSERT(nMsgID &amp;lt; 256); nLenMaxPayload = arMsgBuf[1]; ASSERT(nLenMaxPayload &amp;gt; 0 &amp;amp;&amp;amp; nLenMaxPayload &amp;lt; MAVLINK\_MAX\_PAYLOAD\_LEN); // 获取 message 字段个数 pMavMsg -&amp;gt;nFieldCnts = g\_arMsgInfo[nMsgID].num\_fields; // 获取 message 名称 memset(szTmpName, 0x00, sizeof(szTmpName)); if(strlen(g\_arMsgInfo[nMsgID].name) &amp;lt; LEN\_MSGNM) strcpy(szTmpName, g\_arMsgInfo[nMsgID].name); else strncpy(szTmpName, g\_arMsgInfo[nMsgID].name, LEN\_MSGNM - 1); strUnicodeTmp = AnsiStr2Unicode(szTmpName); if(strUnicodeTmp.GetLength() &amp;gt; LEN\_MSGNM - 1) strUnicodeTmp = strUnicodeTmp.Left(LEN\_MSGNM - 1); \_tcscpy(pMavMsg -&amp;gt;szMsgName, strUnicodeTmp); // 根据 g\_arMsgInfo[] 获取并处理各字段信息 for(i = 0; i &amp;lt; pMavMsg -&amp;gt;nFieldCnts; i++) { strUnicodeTmp = AnsiStr2Unicode((char \*) g\_arMsgInfo[nMsgID].fields[i].name); if(strUnicodeTmp.GetLength() &amp;gt; LEN\_FIELDNM - 1) strUnicodeTmp = strUnicodeTmp.Left(LEN\_FIELDNM - 1); \_tcscpy(pMavMsg -&amp;gt;arField[i].szFieldNm, strUnicodeTmp); // Field Name pMavMsg -&amp;gt;arField[i].nFieldTyp = g\_arMsgInfo[nMsgID].fields[i].type; // Field Type nOfst = g\_arMsgInfo[nMsgID].fields[i].wire\_offset; // 特殊消息的处理 if(nMsgID == MAVLINK\_MSG\_ID\_STATUSTEXT &amp;amp;&amp;amp; i == 1) { memset(szStatusTxt, 0x00, sizeof(szStatusTxt)); memcpy(szStatusTxt, (arMsgBuf + MAVLINK\_NUM\_HEADER\_BYTES + 1), MAVLINK\_MSG\_ID\_STATUSTEXT\_LEN); // 1 为 字符串位置相对载荷开始位置的偏移 strMsgText = AnsiStr2Unicode(szStatusTxt); } else if(nMsgID == MAVLINK\_MSG\_ID\_PARAM\_VALUE &amp;amp;&amp;amp; i == 3) { memset(szValueID, 0x00, sizeof(szValueID)); memcpy(szValueID, (arMsgBuf + MAVLINK\_NUM\_HEADER\_BYTES + 8), MAVLINK\_MSG\_PARAM\_VALUE\_FIELD\_PARAM\_ID\_LEN); strMsgText = AnsiStr2Unicode(szValueID); } else if(nMsgID == MAVLINK\_MSG\_ID\_PARAM\_SET &amp;amp;&amp;amp; i == 3) { memcpy(szValueID, (arMsgBuf + MAVLINK\_NUM\_HEADER\_BYTES + 6), MAVLINK\_MSG\_PARAM\_VALUE\_FIELD\_PARAM\_ID\_LEN); strMsgText = AnsiStr2Unicode(szValueID); } else { // 一般 mavlink msg 的处理 // 获取每个数值所存储的缓冲区 if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_CHAR || g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_UINT8\_T || g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_INT8\_T) { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; ASSERT(nOfst &amp;lt; nLenMaxPayload); } else if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_UINT16\_T || g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_INT16\_T) { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; pMavMsg -&amp;gt;arField[i].arData[1] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 1]; ASSERT(nOfst + 1 &amp;lt; nLenMaxPayload); } else if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_UINT32\_T || g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_INT32\_T) { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; pMavMsg -&amp;gt;arField[i].arData[1] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 1]; pMavMsg -&amp;gt;arField[i].arData[2] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 2]; pMavMsg -&amp;gt;arField[i].arData[3] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 3]; ASSERT(nOfst + 3 &amp;lt; nLenMaxPayload); } else if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_UINT64\_T || g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_INT64\_T) { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; pMavMsg -&amp;gt;arField[i].arData[1] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 1]; pMavMsg -&amp;gt;arField[i].arData[2] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 2]; pMavMsg -&amp;gt;arField[i].arData[3] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 3]; pMavMsg -&amp;gt;arField[i].arData[4] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 4]; pMavMsg -&amp;gt;arField[i].arData[5] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 5]; pMavMsg -&amp;gt;arField[i].arData[6] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 6]; pMavMsg -&amp;gt;arField[i].arData[7] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 7]; ASSERT(nOfst + 7 &amp;lt; nLenMaxPayload); } else if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_FLOAT) // 4 byte { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; pMavMsg -&amp;gt;arField[i].arData[1] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 1]; pMavMsg -&amp;gt;arField[i].arData[2] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 2]; pMavMsg -&amp;gt;arField[i].arData[3] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 3]; ASSERT(nOfst + 3 &amp;lt; nLenMaxPayload); } else if(g\_arMsgInfo[nMsgID].fields[i].type == MAVLINK\_TYPE\_DOUBLE) // 8 byte { pMavMsg -&amp;gt;arField[i].arData[0] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst]; pMavMsg -&amp;gt;arField[i].arData[1] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 1]; pMavMsg -&amp;gt;arField[i].arData[2] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 2]; pMavMsg -&amp;gt;arField[i].arData[3] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 3]; pMavMsg -&amp;gt;arField[i].arData[4] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 4]; pMavMsg -&amp;gt;arField[i].arData[5] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 5]; pMavMsg -&amp;gt;arField[i].arData[6] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 6]; pMavMsg -&amp;gt;arField[i].arData[7] = arMsgBuf[MAVLINK\_NUM\_HEADER\_BYTES + nOfst + 7]; ASSERT(nOfst + 7 &amp;lt; nLenMaxPayload); } else { TRACE(\_T(&amp;quot;\r\n&amp;gt; MAVLinkProtocol.ParseMsg - Unexpect field type: &amp;quot;)); TRACE(\_T(&amp;quot;\r\n&amp;gt; MAVLinkProtocol.ParseMsg - g\_arMsgInfo[nMsgID].fields[i].type = %d&amp;quot;), g\_arMsgInfo[nMsgID].fields[i].type); } } } return nMsgID; } 引自： http://bbs.arm.so/thread-28-1-1.html http://bbs.loveuav.com/thread-288-1-1.html http://blog.csdn.net/u013983741/article/details/48053235 http://blog.csdn.net/msq19895070/article/details/50998847 http://mrsxm.mfzgi5lqnfwg65bomnxw2.erenta.ru/wp-content/uploads/sites/6/2015/05/MAVLINK_FOR_DUMMIESPart1_v.1.1.pdf http://blog.csdn.net/u013983741/article/details/48053235 http://blog.csdn.net/ss15/article/details/9998745#]]></content>
      <categories>
        <category>Mavlink</category>
      </categories>
      <tags>
        <tag>Mavlink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitbucket - 用git 用法]]></title>
    <url>%2FBitbucket%20-%20%E7%94%A8git%20%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[核心流程： 从远端中心repo那里 Git clone 到本地，再在本地开发（add, commit）, 通常会利用branch管理，如果觉得code 没问题了，就push到远端的中心repo上。这里中心的repo 就是 bitbucket上的repo。 git 之后 不需要 减号- git clone https的path 把repo下载到本地 git status 查看哪些文件修改了。 如果提交前，想看看具体那些文件发生变化，可以通过git-diff来查看。git diff 与 git status 区别? git add filelist 或者* 告诉git，这些file改变了，将要commit。只是起到通知和标识的作用 相当于上传照片的时候，&quot;选中&quot;照片的功能，commit 则相当于上传 git commit git commit -m &quot; &quot; git branch分支管理 在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git init时，系统就会创建一个名为&quot;master&quot;的分支。在bitbucket中已经创建了master分支（trunk）我们只需要clone下来即可。而其它分支则通过手工创建。下面列举一些常见的分支策略，这些策略相信会对你的日常开发带来很大的便利。 1.创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。 2.当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。 3.合并别人的工作的时候，最好是创建一个临时的分支用来合并，合并完成后在&quot;fatch&quot;到自己的分支（合并和fatch后面有讲述，不明白就继续往下看好了） 查看分支 – git branch 调用git branch可以查看程序中已经存在的分支和当前分支 创建分支 – git branch 分支名 要创建一个分支，可以使用如下方法: git branch 分支名称 git checkout –b 分支名 使用第一种方法，虽然创建了分支，但是不会将当前工作分支切换到新创建的分支上，因此，还需要命令&quot;git checkout 分支名&quot; 来切换， 而第二种方法不但创建了分支，还将当前工作分支切换到了该分支上。 另外，需要注意，分支名称是有可能出现重名的情况的， 比如说，我在master分支下创建了a和b两个分支，然后切换到b分支，在b分支下又创建了a和c分支。 这种操作是可以进行的。 此时的a分支和master下的a分支实际上是两个不同的分支。因此，在实际使用时，不建议这样的操作，这样会带来命名上的疑惑。 删除分支 – git branch -d或–D 分支名 -d 是删除，-D是强制删除 git branch –D 分支名可以删除分支，但是需要小心，删除后，发生在该分支的所有变化都无法恢复。 切换分支 – git checkout 分支名 如果分支已经存在， 可以通过 git checkout 分支名 来切换工作分支到该分支名 合并分支 – git merge git merge的用法为：git-merge &quot;some memo&quot; 合并的目标分支 合并的来源分支。如： 如果合并有冲突，git会由提示，当前，git merge已经很少用了， 用git pull来替代了。 用法为：git pull 合并的目标分支 合并的来源分支。 如git-pull . dev1 分支的管理到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。 git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单： $ git branch iss53 * master testing 注意看 master 分支前的 * 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行 git branch -v： $ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch &#39;iss53&#39; testing 782fd34 add scott to the author list in the readmes 要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merged 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用 git branch –merged 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）： $ git branch –merged iss53 * master 之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。 另外可以用 git branch –no-merged 查看尚未合并的工作： $ git branch –no-merged testing 它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据： $ git branch -d testing error: The branch &#39;testing&#39; is not fully merged. If you are sure you want to delete it, run &#39;git branch -D testing&#39;. 不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。 与远程sever操作！！ clone pull push 2.7 远程获取一个git库 git-clone 在2.1节提到过，如果你不是一个代码模块的发起者，也不会使用到git-init命令，而是更多的是使用git-clone。通过这个命令，你可以从远端完整获取一个git库，并可以通过一些命令和远端的git交互。 基于git的代码管理的组织结构，往往形成一个树状结构，开发者一般从某个代码模块的管理者的git库通过git-clone取得开发环境，在本地迭代开发后，再提交给该模块的管理者，该模块的管理者检查这些提交并将代码合并到自己的库中，并向更高一级的代码管理者提交自己的模块代码。 git-clone的使用方法如下： git-clone [ssh://]username@ipaddr:path。 其中， &quot;ssh://&quot;可选，也有别的获取方式，如rsync。 Path是远端git的根路径，也叫repository。 通过git-clone获取远端git库后，.git/config中的开发者信息不会被一起clone过来。仍然需要为.git/config文件添加开发者信息。此外，开发者还需要自己添加. gitignore文件 另外，通过git-clone获取的远端git库，只包含了远端git库的当前工作分支。如果想获取其它分支信息，需要使用&quot;git-branch –r&quot; 来查看， 如果需要将远程的其它分支代码也获取过来，可以使用命令&quot; git checkout -b 本地分支名远程分支名&quot;，其中，远程分支名为git-branch –r所列出的分支名， 一般是诸如&quot;origin/分支名&quot;的样子。如果本地分支名已经存在，则不需要&quot;-b&quot;参数。 2.8 从远程获取一个git分支 – git-pull 与git-clone不同， git-pull可以从任意一个git库获取某个分支的内容。用法如下： git-pull username@ipaddr: 远端repository名 远端分支名:本地分支名。这条命令将从远端git库的远端分支名获取到本地git库的一个本地分支中。其中，如果不写本地分支名，则默认pull到本地当前分支。 需要注意的是，git-pull也可以用来合并分支。 和git-merge的作用相同。 因此，如果你的本地分支已经有内容，则git-pull会合并这些文件，如果有冲突会报警。 2.9 将本地分支内容提交到远端分支 – git-push git-push和git-pull正好想反，是将本地某个分支的内容提交到远端某个分支上。用法： git-push username@ipaddr: 远端repository名 本地分支名:远端分支名。这条命令将本地git库的一个本地分支push到远端git库的远端分支名中。 需要格外注意的是，git-push好像不会自动合并文件。这点我的试验表明是这样，但我不能确认是否是我用错了。因此，如果git-push时，发生了冲突，就会被后push的文件内容强行覆盖，而且没有什么提示。 这在合作开发时是很危险的事情。 2.10 库的逆转与恢复 – git-reset 库的逆转与恢复除了用来进行一些废弃的研发代码的重置外，还有一个重要的作用。比如我们从远程clone了一个代码库，在本地开发后，准备提交回远程。但是本地代码库在开发时，有功能性的commit，也有出于备份目的的commit等等。总之，commit的日志中有大量无用log，我们并不想把这些 log在提交回远程时也提交到库中。 因此，就要用到git-reset。 Git-reset的概念比较复杂。它的命令形式：git-reset [–mixed | –soft | –hard] [&lt;commit-ish&gt;] 命令的选项： –mixed 这个是默认的选项。 如git-reset [–mixed] dev1^(dev1^的定义可以参见2.6.5)。它的作用仅是重置分支状态到dev1^, 但是却不改变任何工作文件的内容。即，从dev1^到dev1的所有文件变化都保留了，但是dev1^到dev1之间的所有commit日志都被清除了，而且，发生变化的文件内容也没有通过git-add标识，如果您要重新commit，还需要对变化的文件做一次git-add。这样，commit后，就得到了一份非常干净的提交记录。 –soft 相当于做了git-reset –mixed，后，又对变化的文件做了git-add。如果用了该选项， 就可以直接commit了。 –hard 这个命令就会导致所有信息的回退， 包括文件内容。 一般只有在重置废弃代码时，才用它。 执行后，文件内容也无法恢复回来了。 基于git的合作开发 对于酷讯来说，当我们采用了Git，如何进行合作开发呢？ 具体步骤如下： 3.1 获取最新代码 酷讯会准备一个中心git代码库。首先，我们将整理好的代码分模块在git中心库中建立git库。并将文件add到中心库中。 接下来，开发者通过git-clone将代码从中心库clone到本地开发环境。对于较大的项目，我们还建议每个组选择一个负责人，由这个负责人负责从中心库获取和更新最新的代码，其它开发者从这个负责人的git代码库中clone代码。此时，对开发者来说，这个负责人的git库就是中心库了。 3.2 和中心库进行代码合并 使用过CVS的人都知道， 在commit之前，都要做一次cvs update，以避免和中心库冲突。Git也是如此。 现在我们已经经过了code review， 准备向中心库提交变化了， 在开发的这段时间，也许中心库发生了变化，因此，我们需要在向中心库提交前，再次将中心库的master分支git-pull到本地的master分支上。并且和dev分支做合并。最终，将合并的代码放入master分支。 如果开发过程提交日志过多，可以考虑参照2.10节的介绍做一次git-reset。 此外，如果发现合并过程变化非常多， 出于代码质量考虑，建议再做一次code review 3.3提交代码到中心库 此时，已经完全准备好提交最终的代码了。 通过git-push就可以了。 3.4合作流程总结 大家可以看到，使用git进行合作开发，这一过程和CVS有很多相似性，同时，增强了以下几个环节： 开发者在本地进行迭代开发，可以经常的做commit操作且不会影响他人。 而且即使不在线也可以进行开发。只需要最后向中心库提交一次即可。 大家都知道，如果CVS管理代码，由于我们会常常做commit操作。但是在commit之前cvs update时常会遇到将中心库上的其它最新代码checkout下来的情况，此时，一旦出现问题，就很难确认到底是自己开发的bug还是其它用户的代码带来了影响。 而使用git则避免了用户间的开发互相影响。 更有利于在代码提交前做code review。以往用cvs， 都是代码提交后才做code view。如果发生问题， 也无法避免服务器上有不好的代码。 但是用git，真正向中心库commit前，都是在本地开发，可以方便的进行code review， 然后才提交到中心库。更有利于代码质量。而且，大家应该可以感到，使用git的过程中，更容易对代码进行code review，因为影响因素更小。 创建多分支，更容易在开发中进行多种工作，而使工作间不会互相影响。 比如user2对user1的代码进行code review时，就可以非常方便的保留当时的开发现场，并切换到user1的代码分支，在code review完毕后，也可以非常方便的切换会曾经被中断的工作现场。 诚然，带来这些好处的同时，确实也使得操作比CVS复杂了一些。但我们觉得和前面所能获得的好处相比，这些麻烦是值得的。 当大家用惯了之后会发现，这并不增加多大的复杂性， 而且开发流程会更加自然。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Bitbucket</tag>
        <tag>分布式版本控制系统</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git - 生成ssh key步骤以及如何clone所有的远程分支]]></title>
    <url>%2FGit%20-%20%E7%94%9F%E6%88%90ssh%20key%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95clone%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.html</url>
    <content type="text"><![CDATA[这里以配置github的ssh key为例： 1. 配置** git 用 户 名和 邮 **箱设置Git的user name和email： $ git config –global user.name &quot;用户名&quot; $ git config –global user.email &quot;邮箱&quot; 在config后加上 –global 即可全局设置用户名和邮箱。 2. 生成** ssh key**生成密钥： $ ssh-keygen -t rsa -C &quot;邮箱&quot;按3个回车，密码为空。 然后根据提示连续回车即可在~/.ssh目录下得到id_rsa和id_rsa.pub两个文件，id_rsa.pub文件里存放的就是我们要使用的key。 3. 上** 传 key 到 **githubclip &lt; ~/.ssh/id_rsa.pub 复制key到剪贴板 登录github 点击右上方的Accounting settings图标 选择 SSH key 点击 Add SSH key 4. 测试是否配置成** 功**ssh -T git@github.com 如果配置成功，则会显示： Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access. ** 开始使用 **github1.** 获取源码 **：$ git clone ssh://git@bitbucket.yuneec.com.git 2.这样你的机器上就有一个repo了。3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo仓库初始化： git init 生成快照并存入项目索引： git add . 文件,还有git rm,git mv等等…项目索引提交： git commit -m &quot;说明&quot; 4.协作编程：将本地repo于远程的origin的repo合并，推送本地更新到远程： git push origin master 更新远程更新到本地： git pull origin master 补充：添加远端repo： $ git remote add upstream git://github.com/pjhyett/github-services.git 重命名远端repo： $ git://github.com/pjhyett/github-services.git为&quot;upstream&quot; 解决本地多个** ssh key **问题有的时候，不仅github使用ssh key，工作项目或者其他云平台可能也需要使用ssh key来认证，如果每次都覆盖了原来的id_rsa 文件，那么之前的认证就会失效。这个问题我们可以通过在~/.ssh目录下增加config文件来解决。 下面以配置搜狐云平台的ssh key为例。 1. 第一步依然是配置** git 用 户 名和 邮 **箱git config user.name &quot;用户名&quot;git config user.email &quot;邮箱&quot; 2. 生成** ssh key 时同时指定保存的文件 名**ssh-keygen -t rsa -f ~/.ssh/id_rsa.sohu -C &quot;email&quot; 上面的id_rsa.sohu 就是我们指定的文件名，这时~/.ssh目录下会多出id_rsa.sohu和id_rsa.sohu.pub两个文件，id_rsa.sohu.pub里保存的就是我们要使用的key。 3. 新增并配置** config**文件 添加** config**文件 如果config 文件不存在，先添加；存在则直接修改 touch ~/.ssh/config 在** config**文件里添加如下内容(User表示你的用户名) Host *.cloudscape .sohu .com IdentityFile ~/.ssh/id_rsa.sohu User test 4. 上** 传 key 到云平台后台(省略**)5. 测试** ssh key **是否配置成功ssh -T git@git.cloudscape .sohu .com 成功的话会显示： Welcome to GitLab, username! 至此，本地便成功配置多个ssh key。日后如需添加，则安装上述配置生成key，并修改config文件即可。 6.** 如何 clone 所有的 远 程分支**更新远程分支到本地： git fetch -p git branch -a git一般有很多分支，我们clone到本地的时候一般都是master分支，那么如何切换到其他分支呢？主要命令如下： 1. 查看远程分支 $ git branch -a我在mxnet根目录下运行以上命令： ~/mxnet$ git branch -a * master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/origin/nnvm remotes/origin/piiswrong-patch-1 remotes/origin/v0.9rc1 可以看到，我们现在在master分支下 2. 查看本地分支 ~/mxnet$ git branch * master 3. 切换分支 $ git checkout -b v0.9rc1 origin/v0.9rc1 Branch v0.9rc1 set up to track remote branch v0.9rc1 from origin. Switched to a new branch &#39;v0.9rc1&#39; ＃已经切换到v0.9rc1分支了 $ git branch master * v0.9rc1 ＃切换回master分支 $ git checkout master Switched to branch &#39;master&#39; Your branch is up-to-date with &#39;origin/master&#39;. 解决：（1） 首先，你需要使用$ git clone这个命令克隆一个本地库。之后它会自动克隆一个master分支（这个貌似是必须的）。之后不会克隆任何一个分支下来的。假定你需要一个dev（此处假定远程库中已经存在此分支，也就是你需要克隆的）分支用于开发的话，你需要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是用这个命令创建本地dev分支：$ git checkout -b dev origin/dev 再同步下：$ git pull 这样就实现了克隆dev分支。———————————————————————————— 解决：（2） Git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下： 找一个干净目录，假设是git_work cd git_work git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录 cd project git branch -a，列出所有分支名称如下：remotes/origin/devremotes/origin/release git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支 git checkout -b release origin/release，作用参见上一步解释 git checkout dev，切换回dev分支，并开始开发。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>分布式版本控制系统</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git - 使用指南]]></title>
    <url>%2FGit%20-%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[GIT （分布式版本控制系统）Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。[1] Git的读音为/gɪt/。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。[2] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了 Git 上。 安装下载 git OSX 版 下载 git Windows 版 下载 git Linux 版 创建新仓库创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本： git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵&quot;树&quot;组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令： git add &lt;filename&gt; git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动： git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了 HEAD ，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库： git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是&quot;默认的&quot;。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做&quot;feature_x&quot;的分支，并切换过去： git checkout -b feature_x 切换回主分支： git checkout master 再把新建的分支删掉： git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行： git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行： git merge &lt;branch&gt; 两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功： git add &lt;filename&gt; 在合并改动之前，也可以使用如下命令查看： git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签： git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID： git log 你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动： git checkout – &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： git fetch origin git reset –hard origin/master 有用的贴士内建的图形化 git： gitk 彩色的 git 输出： git config color.ui true 显示历史记录时，只显示一行注释信息： git config format.pretty oneline 交互地添加文件至缓存区： git add -i]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>分布式版本控制系统</tag>
        <tag>Git</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
